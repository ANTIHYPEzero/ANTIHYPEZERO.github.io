<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ANTIHYPEzero</title>
  
  <subtitle>你好！</subtitle>
  <link href="http://antihypezero.github.io/atom.xml" rel="self"/>
  
  <link href="http://antihypezero.github.io/"/>
  <updated>2022-07-15T15:37:06.463Z</updated>
  <id>http://antihypezero.github.io/</id>
  
  <author>
    <name>Antihype</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cs:app lab1</title>
    <link href="http://antihypezero.github.io/2022/07/15/csapp-lab1/"/>
    <id>http://antihypezero.github.io/2022/07/15/csapp-lab1/</id>
    <published>2022-07-15T15:37:06.463Z</published>
    <updated>2022-07-15T15:37:06.463Z</updated>
    
    <content type="html"><![CDATA[<p>借鉴于(<a href="https://zhuanlan.zhihu.com/p/395271636">https://zhuanlan.zhihu.com/p/395271636</a>)</p><p>借鉴于(<a href="https://blog.csdn.net/zzy980511/article/details/120608839">https://blog.csdn.net/zzy980511/article/details/120608839</a>)</p><h2 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h2><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * bitXor - x^y using only ~ and &amp;</span><br><span class="line"> *   Example: bitXor(4, 5) = 1</span><br><span class="line"> *   Legal ops: ~ &amp;</span><br><span class="line"> *   Max ops: 14</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br><span class="line">int bitXor(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int bitXor(int x, int y) &#123;</span><br><span class="line">  return ~(~(~x &amp; y) &amp; ~(x &amp; ~y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * tmin - return minimum two&#x27;s complement integer</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 4</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br><span class="line">int tmin(void)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int tmin(void) &#123;</span><br><span class="line">  return 1 &lt;&lt; 31;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span><br><span class="line"> *     and 0 otherwise</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | +</span><br><span class="line"> *   Max ops: 10</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br><span class="line">int isTmax(int x)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = x + <span class="number">1</span>;    </span><br><span class="line">  x = x + i;        </span><br><span class="line">  x = x + <span class="number">1</span>;     </span><br><span class="line">  </span><br><span class="line">  i = !i;           </span><br><span class="line">  x = x + i;        </span><br><span class="line">  <span class="keyword">return</span> !x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="line"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="line"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 12</span><br><span class="line"> *   Rating: 2</span><br><span class="line"> */</span><br><span class="line">int allOddBits(int x)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int allOddBits(int x) </span><br><span class="line">&#123;</span><br><span class="line">  int i = (0xAA &lt;&lt; 8) | 0xAA;</span><br><span class="line">  int j = (i &lt;&lt; 16) | i;      </span><br><span class="line">  return !((x &amp; j) ^ j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * negate - return -x</span><br><span class="line"> *   Example: negate(1) = -1.</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 5</span><br><span class="line"> *   Rating: 2</span><br><span class="line"> */</span><br><span class="line">int negate(int x)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int negate(int x) </span><br><span class="line">&#123;</span><br><span class="line">  return (~x + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span><br><span class="line"> *   Example: isAsciiDigit(0x35) = 1.</span><br><span class="line"> *            isAsciiDigit(0x3a) = 0.</span><br><span class="line"> *            isAsciiDigit(0x05) = 0.</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 15</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br><span class="line">int isAsciiDigit(int x)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int isAsciiDigit(int x)</span><br><span class="line">&#123;</span><br><span class="line">  int x1 = (x &gt;&gt; 4) ^ 0x3;</span><br><span class="line">  int x2 = (x &gt;&gt; 3) &amp; 0x1;</span><br><span class="line">  int x3 = (x &gt;&gt; 2) &amp; 0x1;</span><br><span class="line">  int x4 = (x &gt;&gt; 1) &amp; 0x1;</span><br><span class="line">  return !x1 &amp; (!x2) | (x2 &amp; !x3 &amp; !x4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * conditional - same as x ? y : z</span><br><span class="line"> *   Example: conditional(2,4,5) = 4</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 16</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br><span class="line">int conditional(int x, int y, int z)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int conditional(int x, int y, int z) </span><br><span class="line">&#123;</span><br><span class="line">  x = !!x;</span><br><span class="line">  x = ~x + 1;</span><br><span class="line">  return (x &amp; y) | (~x &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0</span><br><span class="line"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 24</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br><span class="line">int isLessOrEqual(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int isLessOrEqual(int x, int y) </span><br><span class="line">&#123;</span><br><span class="line">  int val = y + (~x + 1);</span><br><span class="line">  int signedVal = (val &amp; 0x80000000) &gt;&gt; 31;</span><br><span class="line">  int signedX = x &amp; 0x80000000;</span><br><span class="line">  int signedY = y &amp; 0x80000000;</span><br><span class="line">  int flag = ((signedX ^ signedY) &gt;&gt; 31) &amp; 1;</span><br><span class="line">  return (!flag &amp; !signedval) | (flag &amp; (signedX &gt;&gt; 31));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * logicalNeg - implement the ! operator, using all of</span><br><span class="line"> *              the legal operators except !</span><br><span class="line"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span><br><span class="line"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 12</span><br><span class="line"> *   Rating: 4</span><br><span class="line"> */</span><br><span class="line">int logicalNeg(int x)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int logicalNeg(int x)</span><br><span class="line">&#123;</span><br><span class="line">  int nx = (~x + 1);     </span><br><span class="line">  int i = x | nx;</span><br><span class="line">  return (i &gt;&gt; 31) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* howManyBits - return the minimum number of bits required to represent x in</span><br><span class="line"> *             two&#x27;s complement</span><br><span class="line"> *  Examples: howManyBits(12) = 5</span><br><span class="line"> *            howManyBits(298) = 10</span><br><span class="line"> *            howManyBits(-5) = 4</span><br><span class="line"> *            howManyBits(0)  = 1</span><br><span class="line"> *            howManyBits(-1) = 1</span><br><span class="line"> *            howManyBits(0x80000000) = 32</span><br><span class="line"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *  Max ops: 90</span><br><span class="line"> *  Rating: 4</span><br><span class="line"> */</span><br><span class="line">int howManyBits(int x)</span><br><span class="line">&#123;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int howManyBits(int x) </span><br><span class="line">&#123;</span><br><span class="line">  int Sign = x &gt;&gt; 31;</span><br><span class="line">  x = (Sign &amp; ~x)  | (~Sign &amp; x);</span><br><span class="line">  </span><br><span class="line">  int High16 = !!(x &gt;&gt; 16) &lt;&lt; 4;</span><br><span class="line">  x = x &gt;&gt; High16;</span><br><span class="line"></span><br><span class="line">  int High8 = !!(x &gt;&gt; 8) &lt;&lt; 3;</span><br><span class="line">  x = x &gt;&gt; High8;</span><br><span class="line"></span><br><span class="line">  int High4 = !!(x &gt;&gt; 4) &lt;&lt; 2;</span><br><span class="line">  x = x &gt;&gt; High4;</span><br><span class="line"></span><br><span class="line">  int High2 = !!(x &gt;&gt; 2) &lt;&lt; 1;</span><br><span class="line">  x = x &gt;&gt; High2;</span><br><span class="line"></span><br><span class="line">  int High1 = !!(x &gt;&gt; 1); </span><br><span class="line">  x = x &gt;&gt; High1;</span><br><span class="line"></span><br><span class="line">  int High0 = x;</span><br><span class="line">  return High16 + High8 + High4 + High2 + High1 + High0 + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span><br><span class="line"> *   floating point argument f.</span><br><span class="line"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="line"> *   they are to be interpreted as the bit-level representation of</span><br><span class="line"> *   single-precision floating point values.</span><br><span class="line"> *   When argument is NaN, return argument</span><br><span class="line"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="line"> *   Max ops: 30</span><br><span class="line"> *   Rating: 4</span><br><span class="line"> */</span><br><span class="line">unsigned floatScale2(unsigned uf)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">unsigned floatScale2(unsigned uf)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">  unsigned Sign = uf &gt;&gt; 31;             </span><br><span class="line">  unsigned Exp = (uf &gt;&gt; 23) &amp; 0xff;     </span><br><span class="line">  unsigned Frac = uf &amp; 0x7fffff;        </span><br><span class="line"> </span><br><span class="line">  if(Exp == 0xff &amp;&amp; Frac != 0)</span><br><span class="line">    return uf;</span><br><span class="line">  </span><br><span class="line">  unsigned Result = 0;</span><br><span class="line">  </span><br><span class="line">  if(Exp == 0)   </span><br><span class="line">  &#123;</span><br><span class="line">    int Carry = (Frac &lt;&lt; 1) &gt;&gt; 23;</span><br><span class="line">    Frac = (Frac &lt;&lt; 1) &amp; 0x7fffff;  </span><br><span class="line">    Exp = Exp + Carry;</span><br><span class="line">  &#125;</span><br><span class="line">  else if(Exp != 0xff)       </span><br><span class="line">    Exp = Exp + 1;</span><br><span class="line">  </span><br><span class="line">  Result = (Sign &lt;&lt; 31) | (Exp &lt;&lt; 23) | Frac;</span><br><span class="line">  return Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span><br><span class="line"> *   for floating point argument f.</span><br><span class="line"> *   Argument is passed as unsigned int, but</span><br><span class="line"> *   it is to be interpreted as the bit-level representation of a</span><br><span class="line"> *   single-precision floating point value.</span><br><span class="line"> *   Anything out of range (including NaN and infinity) should return</span><br><span class="line"> *   0x80000000u.</span><br><span class="line"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="line"> *   Max ops: 30</span><br><span class="line"> *   Rating: 4</span><br><span class="line"> */</span><br><span class="line">int floatFloat2Int(unsigned uf)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int floatFloat2Int(unsigned uf) </span><br><span class="line">&#123;</span><br><span class="line">  int sign = uf &gt;&gt; 31;</span><br><span class="line">  int exp = ((uf &gt;&gt; 23) &amp; 0xff) - 127;</span><br><span class="line">  int frac = (uf &amp; 0x007fffff) | 0x00800000;</span><br><span class="line">  int value = 0;</span><br><span class="line">  if (exp &lt; 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if (exp &gt; 31) &#123;</span><br><span class="line">    return 0x80000000;</span><br><span class="line">  &#125;</span><br><span class="line">  if (exp &lt; 23) &#123;</span><br><span class="line">    value = frac &gt;&gt; (23 - exp);</span><br><span class="line">  &#125; else if (exp &gt; 23) &#123;</span><br><span class="line">    value = frac &lt;&lt; (exp - 23);</span><br><span class="line">  &#125;</span><br><span class="line">  return sign ? ~value + 1 : value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span><br><span class="line"> *   (2.0 raised to the power x) for any 32-bit integer x.</span><br><span class="line"> *</span><br><span class="line"> *   The unsigned value that is returned should have the identical bit</span><br><span class="line"> *   representation as the single-precision floating-point number 2.0^x.</span><br><span class="line"> *   If the result is too small to be represented as a denorm, return</span><br><span class="line"> *   0. If too large, return +INF.</span><br><span class="line"> *</span><br><span class="line"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while</span><br><span class="line"> *   Max ops: 30</span><br><span class="line"> *   Rating: 4</span><br><span class="line"> */</span><br><span class="line">unsigned floatPower2(int x)</span><br><span class="line">&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">unsigned floatPower2(int x)</span><br><span class="line">&#123;</span><br><span class="line">  if (x &lt; -149) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if (x &lt; -126) &#123;</span><br><span class="line">    return 1 &lt;&lt; (x + 149);</span><br><span class="line">  &#125;</span><br><span class="line">  if (x &lt; 128) &#123;</span><br><span class="line">    return (x + 127) &lt;&lt; 23;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0xff &lt;&lt; 23;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;借鉴于(&lt;a href=&quot;https://zhuanlan.zhihu.com/p/395271636&quot;&gt;https://zhuanlan.zhihu.com/p/395271636&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;借鉴于(&lt;a href=&quot;https://blog.csdn.ne</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据存储</title>
    <link href="http://antihypezero.github.io/2022/07/15/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <id>http://antihypezero.github.io/2022/07/15/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</id>
    <published>2022-07-15T10:39:28.457Z</published>
    <updated>2022-07-15T10:39:28.458Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h3><ul><li><p>比特（ bit ，位）是计算机中处理、存储、传输信息的最小单位</p></li><li><p>二进制信息最基本的计量单位是“字节”( Byte )</p><ul><li>现代计算机中，存储器按字节编址</li><li>字节是最小可寻址单位( addressable unit )</li><li>如果以字节为一个排列单位，则 LSB 表示最低有效字节， MSB 表示最高有效字节</li></ul></li><li><p>除比特（位）和字节外，还经常使用“字”( word ）作为单位</p><ul><li><p>“字”和“字长”的概念不同</p><blockquote><p>IA -32中的“字”有多少位？位字长多少位呢？</p><p>16位32位 </p><p>DWORD :32位 QwORD :64位</p></blockquote><blockquote><p>数据通路指 CPU 内部数据流经的路径以及路径上的部件，主要是 CPU 内部进行数据运算、存储和传送的部件，这些部件的宽度基本上要一致，才能相互匹配。</p></blockquote></li><li><p>“字长”指数据通路的宽度。<strong>”字长”等于 CPU 内部总线的宽度、运算器的位数、通用寄存器的宽度（这些部件的宽度都是一样的）</strong></p></li><li><p>“字”表示被处理信息的单位，用来度量数据类型的宽度</p></li><li><p>字和字长的宽度可以一样，也可不同</p><blockquote><p>例1：对于x86体系结构，不管字长多少，定义“字”的宽度都为16位，而从386开始字长就是32位了<br>例2：对于 MIPS 32体系结构，其字和字长都是32位</p></blockquote></li></ul></li></ul><h3 id="数据量的度量单位"><a href="#数据量的度量单位" class="headerlink" title="数据量的度量单位"></a>数据量的度量单位</h3><ul><li>存储二进制信息时的度量单位要比字节或字大得多</li><li>容量经常使用的单位有：<ul><li>“干字节”( KB ),1KB&#x3D;210字节＝1024B</li><li>“兆字节”( MB ),1MB&#x3D;220字节＝1024KB</li><li>“干兆字节”( GB ),1GB&#x3D;230字节＝1024MB</li><li>“兆兆字节”( TB ),1TB&#x3D;240字节＝1024GB</li></ul></li><li>通信中的带宽使用的单位有：<ul><li>千比特／秒”( kb &#x2F; s ),1kbps&#x3D;103 b &#x2F; s &#x3D;1000 bps </li><li>“兆比特／秒”( Mb &#x2F; s ),1Mbps&#x3D;106 b &#x2F; s &#x3D;1000 kbps</li><li>“干兆比特／秒”( Gb &#x2F; s ),1Gbps&#x3D;109 b &#x2F; s &#x3D;1000 Mbps </li><li>“兆兆比特／秒”( Tb &#x2F; s ),1Tbps&#x3D;1012 b &#x2F; s &#x3D;1000 Gbps</li></ul></li></ul><p><strong>如果把 b 换成 B ，则表示字节而不是比特（位）</strong></p><p><strong>例如，10MBps表示10兆字节／秒</strong></p><h4 id="程序中数据类型的宽度"><a href="#程序中数据类型的宽度" class="headerlink" title="程序中数据类型的宽度"></a>程序中数据类型的宽度</h4><ul><li><p>高级语言支持多种不同类型和不同长度的数据</p><blockquote><p>C 语言中 char 类型的宽<br>度为1个字节，可表示一个字符（非数值数据），也可表示一个8位的整数（数值数据）﹣不同机器上表示的同一种类型的数据可能宽度不同</p></blockquote></li><li><p>必须确定相应的机器级数据表示方式和相应的处理指令</p></li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/07/15/72f3ad0d9c78211e.png"></p><h3 id="数据存储时的排列方式"><a href="#数据存储时的排列方式" class="headerlink" title="数据存储时的排列方式"></a>数据存储时的排列方式</h3><p><strong>多字节数据都存放在连续的字节序列中, 根据数据中各字节在连续字节序列中的排列顺序不同,可以采用两种排列方式:大端方式和小端方式</strong></p><ul><li>大端方式(Big Endian)：MSB所在地址是数的地址</li></ul><table><thead><tr><th>FE</th><th>AB</th><th>04</th><th>11</th><th></th></tr></thead><tbody><tr><td>100</td><td>101</td><td>102</td><td>103</td><td>大端</td></tr><tr><td>MSB</td><td></td><td></td><td>LSB</td><td></td></tr><tr><td>103</td><td>102</td><td>101</td><td>100</td><td>小端</td></tr></tbody></table><ul><li>小端方式(Little Endian)：LSB所在的地址是数的地址</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据宽度&quot;&gt;&lt;a href=&quot;#数据宽度&quot; class=&quot;headerlink&quot; title=&quot;数据宽度&quot;&gt;&lt;/a&gt;数据宽度&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;比特（ bit ，位）是计算机中处理、存储、传输信息的最小单位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;二进制信</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>非数值数据的编码表示</title>
    <link href="http://antihypezero.github.io/2022/07/15/%E9%9D%9E%E6%95%B0%E5%80%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA/"/>
    <id>http://antihypezero.github.io/2022/07/15/%E9%9D%9E%E6%95%B0%E5%80%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA/</id>
    <published>2022-07-15T09:42:28.910Z</published>
    <updated>2022-07-15T09:42:28.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="逻辑数据"><a href="#逻辑数据" class="headerlink" title="逻辑数据"></a>逻辑数据</h3><ul><li>用处<ul><li>表示逻辑(关系)表达式中的逻辑值：真&#x2F;假</li></ul></li><li>表示<ul><li>用一位表示，n位二进制数(位串)可表示n个逻辑数据</li></ul></li><li>运算<ul><li>按位进行，如，按位与&#x2F;按位或&#x2F;逻辑左移&#x2F;逻辑右移</li></ul></li><li>识别<ul><li>逻辑数据和数值数据在形式上并无差别，都是0&#x2F;1序列，计算机靠指令识别</li></ul></li></ul><h3 id="西文字符"><a href="#西文字符" class="headerlink" title="西文字符"></a>西文字符</h3><ul><li>特点<ul><li>用有限个字母可拼写出所有单词</li><li>只需对有限个字母、数学符号和标点符号等辅助字符编码</li><li>所有字符总数不超过256个，使用7或8个二进位可表示</li></ul></li><li>表示<ul><li>常用编码位7位ASCII码</li><li>十进制数、英文字母、专用符号、控制字符</li></ul></li><li>操作<ul><li>字符串操作，如：传送&#x2F;比较等</li></ul></li></ul><h3 id="汉字及国际字符"><a href="#汉字及国际字符" class="headerlink" title="汉字及国际字符"></a>汉字及国际字符</h3><ul><li>汉字特点<ul><li>汉字是表意文字，一个字就是一个图形</li><li>汉字数据量大，总数超过6万字</li></ul></li><li>编码形式<ul><li>输入码：对汉字用相应按键进行编码表示，用于输入</li><li>内码：用于在系统中进行存储、查找、传送等处理</li><li>字模点或轮廓描述：描述汉字字模点阵或轮廓，用于显示&#x2F;打印</li></ul></li></ul><h4 id="GB2312-80字符集"><a href="#GB2312-80字符集" class="headerlink" title="GB2312-80字符集"></a>GB2312-80字符集</h4><ul><li><p>三部分组成</p><ul><li>字母、数字和各种符号，包括英文、俄文、日文平假名与片假名、罗马字母、汉语拼音等共687个</li><li>一级常用汉字共3755个，按汉语拼音排列</li><li>二级常用汉字，共3008个，按偏旁部首排列</li></ul></li><li><p>汉字的区位码</p><ul><li>码表由94行、94列组成，行号为区号，列号为位号，各站7位</li><li>指出汉字在码表中的位置，共14位，区号在左，位号在右</li></ul></li><li><p>汉字的国标码</p><ul><li>每个汉字的区号和位号各自加上32，得到“国标码”</li><li>国标码中区号和位号各占7位，为方便处理与存储，前面添一个0，构成一个字节</li></ul></li></ul><h4 id="汉字内码"><a href="#汉字内码" class="headerlink" title="汉字内码"></a>汉字内码</h4><ul><li><p>至少需2个字节才能表示一个汉字内码</p><ul><li>由汉字的总数（超过6万字）决定!2^16&#x3D;65536</li></ul></li><li><p>可在GB2312国标码的基础上产生汉字内码</p><ul><li><p>为与 ASCI I码区别，将国标码的两个字节的第一位置“1”后得到一种汉字内码（可以有不同的编码方案）</p><blockquote><p>汉字“大”在码表中位于第20行、第83列。因此区位码为00101001010011，在区、位码上各加32得到两个字节编码，即0011010001110011B&#x3D;3473H。前面的34H和字符“4”的 ACSI 码相同，后面的73H和字符“ s ”的 ACSII 码相同，但是，将每个字节的最高位各设为“1”后，就得到其内码：B4F3H(10110100<br>11110011B)，因而不会和 ASCII 码混淆。</p></blockquote></li></ul></li></ul><h4 id="多媒体信息"><a href="#多媒体信息" class="headerlink" title="多媒体信息"></a>多媒体信息</h4><ul><li>图形、图像、音频、视频等信息在机器内部也用0和1表示<ul><li>图形用构建图形的直线或曲线的坐标点及控制点来描述，而这些坐标点或控制点则用数值数据描述</li><li>图像用构成图像的点（像素）的亮度、颜色或灰度等信息来描述，这些亮度或颜色等值则用数值数据描述</li><li>音频信息通过对模拟声音进行采样、量化（用二进制编码）来获得，因此量化后得到的是一个数值数据序列（随时间变化）</li><li>视频信息描述的是随时间变化的图像（每一幅图像称为一帧）</li><li>音乐信息（ MIDI ）通过对演奏的乐器、乐谱等相关的各类信息用0和1进行编码来描述</li></ul></li><li>多媒体信息用一个复杂的数据结构来描述，其中的基本数据或者是数值数据，或者是用0&#x2F;1编码的非数值数据</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;逻辑数据&quot;&gt;&lt;a href=&quot;#逻辑数据&quot; class=&quot;headerlink&quot; title=&quot;逻辑数据&quot;&gt;&lt;/a&gt;逻辑数据&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;用处&lt;ul&gt;
&lt;li&gt;表示逻辑(关系)表达式中的逻辑值：真&amp;#x2F;假&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>浮点数</title>
    <link href="http://antihypezero.github.io/2022/07/15/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    <id>http://antihypezero.github.io/2022/07/15/%E6%B5%AE%E7%82%B9%E6%95%B0/</id>
    <published>2022-07-14T16:42:47.834Z</published>
    <updated>2022-07-15T10:52:35.427Z</updated>
    
    <content type="html"><![CDATA[<h3 id="科学计数法与浮点数"><a href="#科学计数法与浮点数" class="headerlink" title="科学计数法与浮点数"></a>科学计数法与浮点数</h3><blockquote><p>例：7.14 × 10^2003</p><p>0.14为尾数(mantissa)，10为基(base,radix)，2003为阶、指数(Exponent)</p></blockquote><h3 id="规格化数形式"><a href="#规格化数形式" class="headerlink" title="规格化数形式"></a>规格化数形式</h3><blockquote><p>+&#x2F;-1. xxxxxxxxxx   ×   R^Exponent</p></blockquote><p><strong>32-bit 规格化数：</strong></p><p>310</p><table><thead><tr><th>Sign</th><th>Exponent</th><th>Significant</th></tr></thead></table><ul><li>Sign是符号位，占1个bit</li><li>Exponent用移码表示</li><li>Significant表示xxxxxxxxx(部分尾数)</li><li>基是约定信息不必显示</li></ul><h4 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h4><blockquote><p>+&#x2F;-1. xxxxxxxxxx(two)   ×   R^exponent</p><p>规定：小数点前总是“1”，可隐含表示</p></blockquote><p><strong>Single Precision(单精度)：</strong></p><table><thead><tr><th>Sign</th><th>Exponent</th><th>Significand</th></tr></thead><tbody><tr><td>1 bit</td><td>8 bits</td><td>23 bits</td></tr></tbody></table><ul><li>Sign：1表示-，0表示+</li><li>Exponent：<ul><li>SP规格化阶码范围为0000 0001(-126)~1111 1110(127)</li><li>bias为127，1023(double)</li><li>全0与全1表示特殊值</li></ul></li><li>Significand (部分尾数)：<ul><li>规格化尾数最高位总是1，所以隐含表示，省1位</li><li>1+8+23 bits (single)，1+11+52 bits (double)</li></ul></li></ul><p>SP：(-1)^S × (1+Significand) × 2^(Exponent-127)</p><p>DP：(-1)^S × (1+Significand) × 2^(Exponent-1023)</p><blockquote><p>机器数转化为真值</p><p>已知float型变量x的机器数为BEE00000H,求x的值是多少</p></blockquote><blockquote><table><thead><tr><th>1</th><th>0111 1101</th><th>110 0000 0000 0000 0000 0000</th></tr></thead></table><p>Sign：1 </p><p>Exponent：阶码：0111 1101 &#x3D; 125阶码的值：125-127 &#x3D; -2</p><p>Significand：1+0.5+0.25 &#x3D; 1.75</p><p>真值：-1.75 × 2^-2 &#x3D; -0.4375</p></blockquote><blockquote><p>机器数转化为真值</p><p>已知float型变量x的值为-12.75，求x的机器数是多少</p></blockquote><blockquote><p>-12.75 &#x3D; -1100.11B &#x3D; -1.10011B × 2^3</p><p>Sign &#x3D; 1</p><p>Exponent &#x3D; 127+3 &#x3D; 128+2 &#x3D; 1000 0010</p><p>Significant &#x3D; 100 1100 0000 0000 0000 0000</p><p>机器数：</p><table><thead><tr><th>1</th><th>1000 0010</th><th>100 1100 0000 0000 0000 0000</th></tr></thead></table></blockquote><h3 id="特殊数"><a href="#特殊数" class="headerlink" title="特殊数"></a>特殊数</h3><h4 id="0的机器数表示"><a href="#0的机器数表示" class="headerlink" title="0的机器数表示"></a>0的机器数表示</h4><ul><li>Exponent：all zeros</li><li>Significand：all zeros</li></ul><blockquote><p>+0：0 00000000 00000000000000000000000</p><p>-0：1 00000000 00000000000000000000000</p></blockquote><h4 id="∞-x2F-∞的机器数表示"><a href="#∞-x2F-∞的机器数表示" class="headerlink" title="+∞&#x2F;-∞的机器数表示"></a>+∞&#x2F;-∞的机器数表示</h4><ul><li>Exponent：all ones</li><li>Significand：all zeros</li></ul><blockquote><p>+∞：0 11111111 00000000000000000000000</p><p>-∞：1 11111111 00000000000000000000000</p></blockquote><blockquote><p>浮点数除以0的结果是+&#x2F;-∞，而不是溢出异常(整数除以0为异常)</p></blockquote><h4 id="“非数”的表示"><a href="#“非数”的表示" class="headerlink" title="“非数”的表示"></a>“非数”的表示</h4><ul><li>Exponent&#x3D;255</li><li>Significand：nonzero</li></ul><blockquote><p>Not a Numer(NaN)</p></blockquote><blockquote><p>例：sqrt(-4.0) &#x3D; NaN0&#x2F;0 &#x3D; NaN</p><p>+∞-(+∞) &#x3D; NaN∞&#x2F;∞ &#x3D; NaN</p></blockquote><h4 id="非规格化数"><a href="#非规格化数" class="headerlink" title="非规格化数"></a>非规格化数</h4><ul><li>Exponent &#x3D; 0</li><li>Significand：nonzero</li></ul><blockquote><p>表示Denorms(非规格化数)</p></blockquote><h3 id="浮点数精度"><a href="#浮点数精度" class="headerlink" title="浮点数精度"></a>浮点数精度</h3><p>当数据是一个不可表示数时，机器将其转化为最邻近的可表示数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;科学计数法与浮点数&quot;&gt;&lt;a href=&quot;#科学计数法与浮点数&quot; class=&quot;headerlink&quot; title=&quot;科学计数法与浮点数&quot;&gt;&lt;/a&gt;科学计数法与浮点数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;例：7.14 × 10^2003&lt;/p&gt;
&lt;p&gt;0.14为</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C语言中的整数表示</title>
    <link href="http://antihypezero.github.io/2022/07/10/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E8%A1%A8%E7%A4%BA/"/>
    <id>http://antihypezero.github.io/2022/07/10/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E8%A1%A8%E7%A4%BA/</id>
    <published>2022-07-09T17:38:59.231Z</published>
    <updated>2022-07-09T17:38:59.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C语言支持的基本数据类型"><a href="#C语言支持的基本数据类型" class="headerlink" title="C语言支持的基本数据类型"></a>C语言支持的基本数据类型</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/90acb2c8fd9ff1a4.png"></p><h2 id="无符号整数"><a href="#无符号整数" class="headerlink" title="无符号整数"></a>无符号整数</h2><ul><li><p>机器中字的位排列顺序有两种方式：</p><ul><li>高到低位从左到右：0000 0000 0000 1011</li><li>高到低位从右到左：1011 0000 0000 0000</li><li>用LSB表示最低有效位，MSB表示最高有效位</li><li>高到低位多采用从左往右排列</li></ul></li><li><p>一般在全是正数运算且不出现复值结果的场合下，可使用无符号数表示。例如，地址运算、编号表示等。</p></li><li><p>无符号整数的编码中没有符号位</p></li><li><p>能表示的最大值大于位数相同的带符号整数的最大值</p><blockquote><p>8位无符号整数的最大值是255(1111 1111)</p><p>8位有符号整数的最大值是127(0111 1111)</p></blockquote></li></ul><h2 id="带符号整数"><a href="#带符号整数" class="headerlink" title="带符号整数"></a>带符号整数</h2><ul><li>计算机必须能处理正数和负数，用MSB表示数符(0–整数，1–负数)</li><li>有三种定点编码方式<ul><li>原码—-定点小数，用来表示浮点数的尾数</li><li>移码—-定点整数，用于表示浮点数的阶</li><li>补码—-所有计算机都用补码来表示带符号整数</li></ul></li></ul><h2 id="C语言程序中的整数"><a href="#C语言程序中的整数" class="headerlink" title="C语言程序中的整数"></a>C语言程序中的整数</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/b217a8936d5c29ba.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/ce24b332e79a6522.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/96216700398374ce.png"></p><h3 id="编译器处理常量时默认的类型"><a href="#编译器处理常量时默认的类型" class="headerlink" title="编译器处理常量时默认的类型"></a>编译器处理常量时默认的类型</h3><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/8e9e9fc5389d7175.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C语言支持的基本数据类型&quot;&gt;&lt;a href=&quot;#C语言支持的基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;C语言支持的基本数据类型&quot;&gt;&lt;/a&gt;C语言支持的基本数据类型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s3.bmp.ovh/i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>定点数的编码表示</title>
    <link href="http://antihypezero.github.io/2022/07/10/%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA/"/>
    <id>http://antihypezero.github.io/2022/07/10/%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA/</id>
    <published>2022-07-09T17:15:56.465Z</published>
    <updated>2022-07-09T17:15:56.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/0005737aa170a688.png"></p><p>不足：</p><ul><li>0的表示不唯一，不利于编程</li><li>加、减运算方式不统一</li><li>需额外对符号位进行处理，不利于硬件设计</li><li>当a&lt;b时，实现a-b比价困难</li></ul><p><strong>从50年代开始，整数都采用补码来表示，但浮点数的尾数用原码定点小数表示</strong></p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/9dfdea2fe3dac341.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/eccdc12aa75327c5.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/c46bb0da7956a42a.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/33e7f4aeb9f3b082.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/fe721f4dca61b33f.png"></p><h2 id="移码表示"><a href="#移码表示" class="headerlink" title="移码表示"></a>移码表示</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/10/c5a4df4ffc2d941d.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原码&quot;&gt;&lt;a href=&quot;#原码&quot; class=&quot;headerlink&quot; title=&quot;原码&quot;&gt;&lt;/a&gt;原码&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s3.bmp.ovh/imgs/2022/07/10/0005737aa170a688.png&quot;&gt;&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数值与编码</title>
    <link href="http://antihypezero.github.io/2022/07/10/%E6%95%B0%E5%80%BC%E4%B8%8E%E7%BC%96%E7%A0%81/"/>
    <id>http://antihypezero.github.io/2022/07/10/%E6%95%B0%E5%80%BC%E4%B8%8E%E7%BC%96%E7%A0%81/</id>
    <published>2022-07-09T16:43:21.323Z</published>
    <updated>2022-07-09T16:43:21.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="“转换”概念在数据表示中的反应"><a href="#“转换”概念在数据表示中的反应" class="headerlink" title="“转换”概念在数据表示中的反应"></a>“转换”概念在数据表示中的反应</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/09/54dc8463ae2c4121.png"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/09/bc779fddbb4dead3.png"></p><h2 id="信息的二进制编码"><a href="#信息的二进制编码" class="headerlink" title="信息的二进制编码"></a>信息的二进制编码</h2><ul><li><p>机器级数据分两大类</p><ul><li>数值数据：无符号数、带符号整数、浮点数(实数)</li><li>非数值数据：逻辑数(包括位串)、西文字符和汉字</li></ul></li><li><p>计算机内部所有信息用二进制进行编码</p></li><li><p>用二进制的原因</p><ul><li>制造两个稳定态的物理器件容易(电位高&#x2F;低、脉冲有&#x2F;无、正&#x2F;负极)</li><li>二进制编码、计数、运算规则简单</li><li>正好与逻辑命题真&#x2F;假对应，便于逻辑运算</li><li>可方便地用逻辑电路实现算术运算</li></ul></li><li><p>真值和机器数</p><ul><li>机器数：用0和1编码的计算机内部的0&#x2F;1序列</li><li>真值：真正的值，即现实中带正负号的数</li></ul></li></ul><blockquote><p>unsigned short型变量x的真值是127，其机器数是多少？</p><p>127&#x3D;2^7-1，其机器数为0000 0000 0111 1111</p></blockquote><h2 id="数值数据的表示"><a href="#数值数据的表示" class="headerlink" title="数值数据的表示"></a>数值数据的表示</h2><ul><li>数值数据表示的三要素<ul><li>进位计数制</li><li>定、浮点表示</li><li>如何用二进制编码</li></ul></li><li>进位计数制<ul><li>十进制、二进制、十六进制、八进制及其相互转换</li></ul></li><li>定&#x2F;浮点表示(解决小数点问题)<ul><li>定点整数、定点小数</li><li>浮点数(可用一个定点小数和一个定点整数来表示)</li></ul></li><li>定点数的编码(解决正负号问题)<ul><li>原码、补码、反码、移码</li></ul></li></ul><h2 id="数制及其转化"><a href="#数制及其转化" class="headerlink" title="数制及其转化"></a>数制及其转化</h2><h3 id="R进位计数制"><a href="#R进位计数制" class="headerlink" title="R进位计数制"></a>R进位计数制</h3><ul><li>采用R个基本符号(0，1，2，3，R-1)表示各位数字</li><li>逢R进1</li><li>对于每一数位i，该位上的权为R^i</li><li>R被称为该数字系统的基</li></ul><p>八进制：R&#x3D;8，基本符号为0，1，2，3，4，5，6，7 (后缀”O”表示)</p><p>十六进制：R&#x3D;16，基本符号为0，1，2，3，4，5，6，7，8，9，A，B，C，D，E，F (后缀”H”或前缀”OX”表示)</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/09/b2070961757cdc98.png"></p><h3 id="进制间转化"><a href="#进制间转化" class="headerlink" title="进制间转化"></a>进制间转化</h3><ul><li>略</li></ul><h2 id="定点数和浮点数"><a href="#定点数和浮点数" class="headerlink" title="定点数和浮点数"></a>定点数和浮点数</h2><ul><li>计算机中只能通过约定小数点的位置来表示<ul><li>小数点位置约定在固定位置的数称为定点数</li><li>小数点位置约定为可浮动的数称为浮点数</li></ul></li><li>定点小数用来表示浮点数的尾数部分</li><li>定点整数用来表示整数，分带符号整数和无符号整数</li><li>任何实数：X&#x3D;(-1)^s* M * R^E<ul><li>其中，S取值为0或1，决定X的符号；M是二进制定点小数，为X的尾数；E是一个二进制定点整数，为数X的阶或指数 ；R是基数，可以是2、4、8等。只要表示S、M、E，就能确定X的值，这称为浮点数。</li></ul></li></ul><table><thead><tr><th align="center">S</th><th align="center">E</th><th align="center">M</th></tr></thead></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;“转换”概念在数据表示中的反应&quot;&gt;&lt;a href=&quot;#“转换”概念在数据表示中的反应&quot; class=&quot;headerlink&quot; title=&quot;“转换”概念在数据表示中的反应&quot;&gt;&lt;/a&gt;“转换”概念在数据表示中的反应&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>冯·诺伊曼结构与现代计算机结构</title>
    <link href="http://antihypezero.github.io/2022/07/09/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%E4%B8%8E%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84/"/>
    <id>http://antihypezero.github.io/2022/07/09/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%E4%B8%8E%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84/</id>
    <published>2022-07-08T18:11:45.808Z</published>
    <updated>2022-07-09T10:23:08.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冯·诺伊曼结构"><a href="#冯·诺伊曼结构" class="headerlink" title="冯·诺伊曼结构"></a>冯·诺伊曼结构</h2><h3 id="其最重要的思想时”存储程序“工作方式："><a href="#其最重要的思想时”存储程序“工作方式：" class="headerlink" title="其最重要的思想时”存储程序“工作方式："></a>其最重要的思想时”<em>存储程序</em>“工作方式：</h3><p>任何要计算机完成的工作都要先被编写成程序，然后将程序和原始数据送入主存并启动执行。一旦程序被启动，计算机应能在不需操作人员干预下，自动完成逐条取出指令的任务。</p><ul><li>要有个主存存放程序和数据</li><li>要有一个自动逐条去除指令的部件</li><li>要有能具体执行指令(即运算)的部件</li><li>程序由指令构成</li><li>指令描述如何对数据进行处理</li><li>要有将程序和原始数据输入计算机的部件</li><li>要有将运算结果输出的部件</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/07/09/1e5f1ed8b6e2fcba.jpg" title="IAS计算机结构"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/09/796fe2c8c1557377.png" title="冯·诺伊曼计算机模型"></p><p>早期，部件之间用<strong>分散方式</strong>相连</p><p>现在，部件之间大多用<strong>总线方式</strong>相连</p><h3 id="冯·诺伊曼结构的主要思想："><a href="#冯·诺伊曼结构的主要思想：" class="headerlink" title="冯·诺伊曼结构的主要思想："></a>冯·诺伊曼结构的主要思想：</h3><ol><li>计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本组件组成。</li><li>各基本部件的功能是:<ul><li><strong>存储器</strong>不仅能存放数据，而且能存放指令，形式上两者没有区别名单计算机应能区分数据还是指令；</li><li><strong>控制器</strong>应能自动取出指令来执行；</li><li><strong>运算器</strong>应能进行加&#x2F;减&#x2F;乘&#x2F;除四种基本运算，并且能进行一些逻辑运算和附加运算：</li><li>操作人员可以通过<strong>输入设备、输出设备</strong>和主机进行通信。</li></ul></li><li>内部以<strong>二进制</strong>表示指令和数据，每条指令由操作码和地址吗两部分组成。操作码操作类型，地址码指出操作数的地址，由一串指令组成程序。</li><li>采用”<strong>存储程序</strong>“工作方式</li></ol><h2 id="现代计算机结构"><a href="#现代计算机结构" class="headerlink" title="现代计算机结构"></a>现代计算机结构</h2><p><img src="https://i.bmp.ovh/imgs/2022/07/09/6e24f636df2a3e9e.png" title="现代计算机结构模型"></p><p>CPU:中央处理器；  PC：程序计数器；MAR:存储器地址寄存器</p><p>ALU：算术逻辑部件；IR：指令寄存器；  MDR：存储器数据寄存器</p><p>GPRs:通用寄存器组(由若干通用寄存器组成，早期就是累加器)</p><h3 id="计算机工作方式"><a href="#计算机工作方式" class="headerlink" title="计算机工作方式"></a>计算机工作方式</h3><ol><li>数据和操作指令按序存放存储器，有对应的存储单元地址(原材料和菜谱放在架子上，每个架子有编号)</li><li>从某一指定存储地址开始(某一指定菜谱)</li><li>取指令并译码(看菜谱)</li><li>取数据(拿原材料)</li><li>指令执行并回写结果(进行做菜并装盘)</li><li>算出下一存储地址(算出下一道菜所用菜谱的位置)</li></ol><h3 id="数据与指令都存放在存储器中，都是0-x2F-1序列，为了分辨，我们需要知道"><a href="#数据与指令都存放在存储器中，都是0-x2F-1序列，为了分辨，我们需要知道" class="headerlink" title="数据与指令都存放在存储器中，都是0&#x2F;1序列，为了分辨，我们需要知道"></a>数据与指令都存放在存储器中，都是0&#x2F;1序列，为了分辨，我们需要知道</h3><ul><li>操作码(操作性质)</li><li>源操作数1 或&#x2F;和 源操作数2 (立即数、寄存器编号、存储地址)</li><li>目的操作数地址 (寄存器编号、存储地址)</li><li>存储地址地址的描述与操作数的数据结构有关</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;冯·诺伊曼结构&quot;&gt;&lt;a href=&quot;#冯·诺伊曼结构&quot; class=&quot;headerlink&quot; title=&quot;冯·诺伊曼结构&quot;&gt;&lt;/a&gt;冯·诺伊曼结构&lt;/h2&gt;&lt;h3 id=&quot;其最重要的思想时”存储程序“工作方式：&quot;&gt;&lt;a href=&quot;#其最重要的思想时”存储程序“</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机系统基础</title>
    <link href="http://antihypezero.github.io/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <id>http://antihypezero.github.io/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</id>
    <published>2022-07-08T18:11:43.224Z</published>
    <updated>2022-07-09T12:11:51.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Hello World!\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这个程序，<em><strong>GCC</strong></em>编译器编译过程可分为四个阶段—-预处理阶段、编译阶段、汇编阶段、链接阶段</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/ca9a81b4b8efc7a2.jpg"></p><p>理解编译系统如何工作对我们有很大益处：</p><ul><li><p>优化程序性嫩滑</p></li><li><p>理解链接时的错误</p></li><li><p>规避安全漏洞</p></li></ul><h2 id="系统的硬件组织"><a href="#系统的硬件组织" class="headerlink" title="系统的硬件组织"></a>系统的硬件组织</h2><ol><li>总线</li><li>I&#x2F;O(输入&#x2F;输出)设备</li><li>主存</li><li>处理器</li></ol><p><img src="https://i.bmp.ovh/imgs/2022/07/08/ffe190ed0a38cc22.jpg"></p><h2 id="运行hello-c"><a href="#运行hello-c" class="headerlink" title="运行hello.c"></a>运行hello.c</h2><p><img src="https://i.bmp.ovh/imgs/2022/07/08/41ab762fced6ea1d.jpg"></p><p><img src="https://i.bmp.ovh/imgs/2022/07/08/5cbc493e8b46cb19.jpg"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/312f9b6926cd25d2.jpg"></p><h2 id="开发和运行程序需要什么支撑"><a href="#开发和运行程序需要什么支撑" class="headerlink" title="开发和运行程序需要什么支撑"></a>开发和运行程序需要什么支撑</h2><p>用高级语言开发程序需要复杂的支撑环境</p><ul><li>需要编辑器编写源程序</li><li>需要一套翻译转换软件处理各类源程序<ul><li>编译方式：预处理程序、编译器、汇编器、链接器</li><li>解释方式：解释程序</li></ul></li><li>需要一个可以执行程序的界面(环境)<ul><li>GUI方式：图形用户界面</li><li>CUI方式：命令行用户界面</li></ul></li></ul><p>支撑程序开发和运行的环境由<strong>系统软件</strong>提供</p><p>最重要的系统软件是<strong>操作系统</strong>和<strong>语言处理系统</strong></p><p>语言处理系统运行在操作系统之上，操作系统利用指令管理硬件</p><h2 id="计算机系统层次"><a href="#计算机系统层次" class="headerlink" title="计算机系统层次"></a>计算机系统层次</h2><ul><li><p>最早的计算机用机器语言编程</p><ul><li><p>机器语言称为第一代成语设计语言(1GL)</p><p><strong>应用程序—-指令集体系结构—-计算机硬件</strong></p></li></ul></li><li><p>后来用汇编语言编程</p><ul><li><p>汇编语言称为第二代程序设计语言(2GL)</p><p><strong>应用程序—-汇编程序—-操作系统—-指令集体系结构—-计算机硬件</strong></p></li></ul></li><li><p>现代计算机用高级语言编程</p><ul><li><p>第三代程序语言(3GL)为过程式语言，编码时需要描述实现过程，即”如何做”</p></li><li><p>第四代程序设计语言(4GL)为非过程化语言，编码时只需说明”做什么”，不需描述具体的算法实现细节。</p><p><strong>应用程序—-语言处理系统—-操作系统—-指令集体系结构—-计算机硬件</strong></p></li></ul></li></ul><p><strong>语言处理系统</strong>包括：各种语言处理程序(如编译、汇编、链接)、运行时系统(如库函数、调试、优化等功能)</p><p><strong>操作系统</strong>包括人机交互界面、提供服务功能的内核例程</p><p><em>可以看出：语言的发展是一个不断</em>*”抽象”*<em>的过程，因而，相应的计算机系统也不断有新的层次出现</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;编译系统&quot;&gt;&lt;a href=&quot;#编译系统&quot; class=&quot;headerlink&quot; title=&quot;编译系统&quot;&gt;&lt;/a&gt;编译系统&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://antihypezero.github.io/2022/07/05/hello-world/"/>
    <id>http://antihypezero.github.io/2022/07/05/hello-world/</id>
    <published>2022-07-04T17:15:38.584Z</published>
    <updated>2022-07-08T18:08:32.865Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
